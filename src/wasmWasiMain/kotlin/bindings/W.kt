// Generated by `wit-bindgen` 0.25.0. DO NOT EDIT!

@file:OptIn(UnsafeWasmMemoryApi::class)

import kotlin.wasm.unsafe.*

object Jsiface {
  class X : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Jsiface_X_drop(__handle.value)
    }

    public constructor(
        a: Int
    ) : this(
        ResourceHandle(
            run(
                fun(): Int {
                  // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
                  withScopedMemoryAllocator { allocator ->
                    val ret: Int = __wasm_import_constructor(a)
                    freeAllComponentModelReallocAllocatedMemory()
                    val resource = ret
                    return resource
                  }
                  // </editor-fold>
                })))

    public fun getA(): Int {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_getA(handle)
        freeAllComponentModelReallocAllocatedMemory()
        return ret
      }
      // </editor-fold>
    }

    public fun setA(a: Int): Unit {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        __wasm_import_setA(handle, a)
        freeAllComponentModelReallocAllocatedMemory()
      }
      // </editor-fold>
    }

    companion object {
      public fun add(x: Jsiface.X, a: Int): Jsiface.X {
        // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
        withScopedMemoryAllocator { allocator ->
          var handle = x.__handle.value
          val ret: Int = __wasm_import_add(handle, a)
          freeAllComponentModelReallocAllocatedMemory()
          val resource = Jsiface.X(ResourceHandle(ret))
          return resource
        }
        // </editor-fold>
      }
    }
  }
}

object Iface {

  data class Ab(
      var a: String,
      var b: String,
  )

  sealed interface V {
    data class A(val value: Int) : V

    data class B(val value: Float) : V
  }

  enum class Color {
    HOT_PINK,
    LIME_GREEN,
    NAVY_BLUE,
  }

  value class Fg internal constructor(val _value: Long) {
    constructor(
        a: Boolean = false,
        b: Boolean = false,
        c: Boolean = false,
        d: Boolean = false,
        e: Boolean = false,
    ) : this(
        0L or
            (if (a) (1L shl 0) else 0L) or
            (if (b) (1L shl 1) else 0L) or
            (if (c) (1L shl 2) else 0L) or
            (if (d) (1L shl 3) else 0L) or
            (if (e) (1L shl 4) else 0L))

    val a: Boolean
      get() = (_value and (1L shl 0)) != 0L

    val b: Boolean
      get() = (_value and (1L shl 1)) != 0L

    val c: Boolean
      get() = (_value and (1L shl 2)) != 0L

    val d: Boolean
      get() = (_value and (1L shl 3)) != 0L

    val e: Boolean
      get() = (_value and (1L shl 4)) != 0L
  }

  public fun markdownToHtml(x: String): String {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val bytearray = x.encodeToByteArray()
      val len = bytearray.size
      val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

      val ptr0 = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_markdownToHtml(ptr, len, ptr0)
      freeAllComponentModelReallocAllocatedMemory()
      return STRING_FROM_MEM((ptr0 + 0).ptr.loadInt(), (ptr0 + 4).ptr.loadInt())
    }
    // </editor-fold>
  }

  public fun test1(
      p1: Boolean,
      p2: Byte,
      p3: Short,
      p4: Int,
      p5: Long,
      p6: UByte,
      p7: UShort,
      p8: UInt,
      p9: ULong,
      p10: Int
  ): String {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_test1(
          (if (p1) 1 else 0),
          p2.toInt(),
          p3.toInt(),
          p4,
          p5,
          p6.toInt(),
          p7.toInt(),
          p8.toInt(),
          p9.toLong(),
          p10,
          ptr)
      freeAllComponentModelReallocAllocatedMemory()
      return STRING_FROM_MEM((ptr + 0).ptr.loadInt(), (ptr + 4).ptr.loadInt())
    }
    // </editor-fold>
  }

  public fun test2(x: List<String?>): List<String> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val address = allocator.allocate(x.size * 12 /*, align=4*/).address.toInt()
      for ((index, el) in x.withIndex()) {
        val base = address + (index * 12)
        val payload0 = el
        if (payload0 != null) {
          (base + 0).ptr.storeByte(1.toByte())

          val bytearray = payload0.encodeToByteArray()
          val len = bytearray.size
          val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

          (base + 8).ptr.storeInt(len)
          (base + 4).ptr.storeInt(ptr)
        } else {
          (base + 0).ptr.storeByte(0.toByte())
        }
      }
      val ptr1 = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_test2(address, x.size, ptr1)
      freeAllComponentModelReallocAllocatedMemory()

      val list = ArrayList<String>((ptr1 + 4).ptr.loadInt())
      for (i in 0 until (ptr1 + 4).ptr.loadInt()) {
        val base = ((ptr1 + 0).ptr.loadInt()) + (i * 8)

        list.add(STRING_FROM_MEM((base + 0).ptr.loadInt(), (base + 4).ptr.loadInt()))
      }
      return list
    }
    // </editor-fold>
  }

  public fun test3(x: Option<Option<Int?>>): Int {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val option11: Int
      val option12: Int
      val option13: Int
      val option14: Int
      val option15 = x
      if (option15 is Option.Some) {
        val payload0 = option15.value
        val option7: Int
        val option8: Int
        val option9: Int
        val option10 = payload0
        if (option10 is Option.Some) {
          val payload2 = option10.value
          val option: Int
          val option5: Int
          val payload4 = payload2
          if (payload4 != null) {
            option = 1
            option5 = payload4
          } else {
            option = 0
            option5 = 0
          }
          option7 = 1
          option8 = option
          option9 = option5
        } else {
          option7 = 0
          option8 = 0
          option9 = 0
        }
        option11 = 1
        option12 = option7
        option13 = option8
        option14 = option9
      } else {
        option11 = 0
        option12 = 0
        option13 = 0
        option14 = 0
      }
      val ret: Int = __wasm_import_test3(option11, option12, option13, option14)
      freeAllComponentModelReallocAllocatedMemory()
      return ret
    }
    // </editor-fold>
  }

  public fun testRecord(x: Iface.Ab): Iface.Ab {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val bytearray = x.a.encodeToByteArray()
      val len = bytearray.size
      val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

      val bytearray2 = x.b.encodeToByteArray()
      val len1 = bytearray2.size
      val ptr0 = allocator.writeToLinearMemory(bytearray2).address.toInt()

      val ptr3 = /* RETURN_ADDRESS_ALLOC(size=16, align=4)*/ allocator.allocate(16).address.toInt()
      __wasm_import_testRecord(ptr, len, ptr0, len1, ptr3)
      freeAllComponentModelReallocAllocatedMemory()
      return Iface.Ab(
          STRING_FROM_MEM((ptr3 + 0).ptr.loadInt(), (ptr3 + 4).ptr.loadInt()),
          STRING_FROM_MEM((ptr3 + 8).ptr.loadInt(), (ptr3 + 12).ptr.loadInt()),
      )
    }
    // </editor-fold>
  }

  public fun testResult(x: Boolean): Result<Int> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_testResult((if (x) 1 else 0), ptr)
      freeAllComponentModelReallocAllocatedMemory()
      val result =
          if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
            Result<Int>.success((ptr + 4).ptr.loadInt())
          } else {
            Result<Int>.failure(ComponentException((ptr + 4).ptr.loadInt()))
          }
      return result
    }
    // </editor-fold>
  }

  public fun testTuple(
      x1: Boolean,
      x2: Pair<Boolean, String>,
      x3: Triple<Boolean, String, Int>
  ): Tuple6<Boolean, Boolean, String, Boolean, String, Int> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val bytearray = x2.second.encodeToByteArray()
      val len = bytearray.size
      val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

      val bytearray2 = x3.second.encodeToByteArray()
      val len1 = bytearray2.size
      val ptr0 = allocator.writeToLinearMemory(bytearray2).address.toInt()

      val ptr3 = /* RETURN_ADDRESS_ALLOC(size=28, align=4)*/ allocator.allocate(28).address.toInt()
      __wasm_import_testTuple(
          (if (x1) 1 else 0),
          (if (x2.first) 1 else 0),
          ptr,
          len,
          (if (x3.first) 1 else 0),
          ptr0,
          len1,
          x3.third,
          ptr3)
      freeAllComponentModelReallocAllocatedMemory()
      return Tuple6<Boolean, Boolean, String, Boolean, String, Int>(
          ((ptr3 + 0).ptr.loadUByte().toInt() != 0),
          ((ptr3 + 1).ptr.loadUByte().toInt() != 0),
          STRING_FROM_MEM((ptr3 + 4).ptr.loadInt(), (ptr3 + 8).ptr.loadInt()),
          ((ptr3 + 12).ptr.loadUByte().toInt() != 0),
          STRING_FROM_MEM((ptr3 + 16).ptr.loadInt(), (ptr3 + 20).ptr.loadInt()),
          (ptr3 + 24).ptr.loadInt(),
      )
    }
    // </editor-fold>
  }

  public fun testVariant(x: Iface.V): Iface.V {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      // VariantLower START
      val variant: Int
      val variant1: Int
      when (val x2 = x) {
        is Iface.V.A -> {
          val payload = x2.value
          variant = 0
          variant1 = payload
        }
        is Iface.V.B -> {
          val payload0 = x2.value
          variant = 1
          variant1 = payload0.toRawBits()
        }
        else -> error("unreachable")
      }
      // VariantLower END
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_testVariant(variant, variant1, ptr)
      freeAllComponentModelReallocAllocatedMemory()
      // VariantLift START.
      val variant3 =
          when ((ptr + 0).ptr.loadUByte().toInt()) {
            0 -> {
              Iface.V.A((ptr + 4).ptr.loadInt())
            }
            1 -> {
              Iface.V.B((ptr + 4).ptr.loadFloat())
            }
            else -> error("unreachable")
          }
      // VariantLift END
      return variant3
    }
    // </editor-fold>
  }

  public fun testEnum(x: Iface.Color): Int {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Int = __wasm_import_testEnum(x.ordinal)
      freeAllComponentModelReallocAllocatedMemory()
      return ret
    }
    // </editor-fold>
  }

  public fun testFlags(x: Iface.Fg): String {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_testFlags(x._value.toInt(), ptr)
      freeAllComponentModelReallocAllocatedMemory()
      return STRING_FROM_MEM((ptr + 0).ptr.loadInt(), (ptr + 4).ptr.loadInt())
    }
    // </editor-fold>
  }
}

object Environment {
  /**
   * Get the POSIX-style environment variables.
   *
   * Each environment variable is provided as a pair of string variable names and string value.
   *
   * Morally, these are a value import, but until value imports are available in the component
   * model, this import function should return the same values each time it is called.
   */
  public fun getEnvironment(): List<Pair<String, String>> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_getEnvironment(ptr)
      freeAllComponentModelReallocAllocatedMemory()

      val list = ArrayList<Pair<String, String>>((ptr + 4).ptr.loadInt())
      for (i in 0 until (ptr + 4).ptr.loadInt()) {
        val base = ((ptr + 0).ptr.loadInt()) + (i * 16)

        list.add(
            Pair<String, String>(
                STRING_FROM_MEM((base + 0).ptr.loadInt(), (base + 4).ptr.loadInt()),
                STRING_FROM_MEM((base + 8).ptr.loadInt(), (base + 12).ptr.loadInt()),
            ))
      }
      return list
    }
    // </editor-fold>
  }
  /** Get the POSIX-style arguments to the program. */
  public fun getArguments(): List<String> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_getArguments(ptr)
      freeAllComponentModelReallocAllocatedMemory()

      val list = ArrayList<String>((ptr + 4).ptr.loadInt())
      for (i in 0 until (ptr + 4).ptr.loadInt()) {
        val base = ((ptr + 0).ptr.loadInt()) + (i * 8)

        list.add(STRING_FROM_MEM((base + 0).ptr.loadInt(), (base + 4).ptr.loadInt()))
      }
      return list
    }
    // </editor-fold>
  }
  /**
   * Return a path that programs should use as their initial current working directory, interpreting
   * `.` as shorthand for this.
   */
  public fun initialCwd(): String? {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
      __wasm_import_initialCwd(ptr)
      freeAllComponentModelReallocAllocatedMemory()
      // OptionLift start
      val option =
          if ((ptr + 0).ptr.loadUByte().toInt() == 1) {
            STRING_FROM_MEM((ptr + 4).ptr.loadInt(), (ptr + 8).ptr.loadInt())
          } else {
            null
          }
      // OptionLift end
      return option
    }
    // </editor-fold>
  }
}

object Exit {
  /** Exit the current instance and any linked instances. */
  public fun exit(status: Result<Unit>): Unit {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val result: Int
      if (status.isFailure) {
        result = 1
      } else {
        result = 0
      }
      __wasm_import_exit(result)
      freeAllComponentModelReallocAllocatedMemory()
    }
    // </editor-fold>
  }
}

object Error {
  /**
   * A resource which represents some error information.
   *
   * The only method provided by this resource is `to-debug-string`, which provides some
   * human-readable information about the error.
   *
   * In the `wasi:io` package, this resource is returned through the `wasi:io/streams/stream-error`
   * type.
   *
   * To provide more specific error information, other interfaces may provide functions to further
   * "downcast" this error into more specific error information. For example, `error`s returned in
   * streams derived from filesystem types to be described using the filesystem's own error-code
   * type, using the function `wasi:filesystem/types/filesystem-error-code`, which takes a parameter
   * `borrow<error>` and returns `option<wasi:filesystem/types/error-code>`.
   *
   * The set of functions which can "downcast" an `error` into a more concrete type is open.
   */
  class Error : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Error_Error_drop(__handle.value)
    }
    /**
     * Returns a string that is suitable to assist humans in debugging this error.
     *
     * WARNING: The returned string should not be consumed mechanically! It may change across
     * platforms, hosts, or other implementation details. Parsing this string is a major
     * platform-compatibility hazard.
     */
    public fun toDebugString(): String {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
        __wasm_import_toDebugString(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        return STRING_FROM_MEM((ptr + 0).ptr.loadInt(), (ptr + 4).ptr.loadInt())
      }
      // </editor-fold>
    }

    companion object {}
  }
}

object Poll {
  /** `pollable` represents a single I/O event which may be ready, or not. */
  class Pollable : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Poll_Pollable_drop(__handle.value)
    }
    /**
     * Return the readiness of a pollable. This function never blocks.
     *
     * Returns `true` when the pollable is ready, and `false` otherwise.
     */
    public fun ready(): Boolean {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_ready(handle)
        freeAllComponentModelReallocAllocatedMemory()
        return (ret != 0)
      }
      // </editor-fold>
    }
    /**
     * `block` returns immediately if the pollable is ready, and otherwise blocks until ready.
     *
     * This function is equivalent to calling `poll.poll` on a list containing only this pollable.
     */
    public fun block(): Unit {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        __wasm_import_block(handle)
        freeAllComponentModelReallocAllocatedMemory()
      }
      // </editor-fold>
    }

    companion object {}
  }
  /**
   * Poll for completion on a set of pollables.
   *
   * This function takes a list of pollables, which identify I/O sources of interest, and waits
   * until one or more of the events is ready for I/O.
   *
   * The result `list<u32>` contains one or more indices of handles in the argument list that is
   * ready for I/O.
   *
   * If the list contains more elements than can be indexed with a `u32` value, this function traps.
   *
   * A timeout can be implemented by adding a pollable from the wasi-clocks API to the list.
   *
   * This function does not return a `result`; polling in itself does not do any I/O so it doesn't
   * fail. If any of the I/O sources identified by the pollables has an error, it is indicated by
   * marking the source as being reaedy for I/O.
   */

  public fun poll(in_: List<Poll.Pollable>): List<UInt> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val address = allocator.allocate(in_.size * 4 /*, align=4*/).address.toInt()
      for ((index, el) in in_.withIndex()) {
        val base = address + (index * 4)
        var handle = el.__handle.value
        (base + 0).ptr.storeInt(handle)
      }
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_poll(address, in_.size, ptr)
      freeAllComponentModelReallocAllocatedMemory()

      val list = ArrayList<UInt>((ptr + 4).ptr.loadInt())
      for (i in 0 until (ptr + 4).ptr.loadInt()) {
        val base = ((ptr + 0).ptr.loadInt()) + (i * 4)

        list.add((base + 0).ptr.loadInt().toUInt())
      }
      return list
    }
    // </editor-fold>
  }
}

object Streams {

  /** An error for input-stream and output-stream operations. */
  sealed interface StreamError {
    data class LastOperationFailed(val value: Error.Error) : StreamError

    data object Closed : StreamError
  }
  /**
   * An input bytestream.
   *
   * `input-stream`s are *non-blocking* to the extent practical on underlying platforms. I/O
   * operations always return promptly; if fewer bytes are promptly available than requested, they
   * return the number of bytes promptly available, which could even be zero. To wait for data to be
   * available, use the `subscribe` function to obtain a `pollable` which can be polled for using
   * `wasi:io/poll`.
   */

  class InputStream : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Streams_InputStream_drop(__handle.value)
    }
    /**
     * Perform a non-blocking read from the stream.
     *
     * When the source of a `read` is binary data, the bytes from the source are returned verbatim.
     * When the source of a `read` is known to the implementation to be text, bytes containing the
     * UTF-8 encoding of the text are returned.
     *
     * This function returns a list of bytes containing the read data, when successful. The returned
     * list will contain up to `len` bytes; it may return fewer than requested, but not more. The
     * list is empty when no bytes are available for reading at this time. The pollable given by
     * `subscribe` will be ready when more bytes are available.
     *
     * This function fails with a `stream-error` when the operation encounters an error, giving
     * `last-operation-failed`, or when the stream is closed, giving `closed`.
     *
     * When the caller gives a `len` of 0, it represents a request to read 0 bytes. If the stream is
     * still open, this call should succeed and return an empty list, or otherwise fail with
     * `closed`.
     *
     * The `len` parameter is a `u64`, which could represent a list of u8 which is not possible to
     * allocate in wasm32, or not desirable to allocate as as a return value by the callee. The
     * callee may return a list of bytes less than `len` in size while more bytes are available for
     * reading.
     */
    public fun read(len: ULong): Result<List<UByte>> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_read(handle, len.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {

              val list = ArrayList<UByte>((ptr + 8).ptr.loadInt())
              for (i in 0 until (ptr + 8).ptr.loadInt()) {
                val base = ((ptr + 4).ptr.loadInt()) + (i * 1)

                list.add((base + 0).ptr.loadUByte().toInt().toUByte())
              }

              Result<List<UByte>>.success(list)
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 8).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<List<UByte>>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Read bytes from a stream, after blocking until at least one byte can be read. Except for
     * blocking, behavior is identical to `read`.
     */
    public fun blockingRead(len: ULong): Result<List<UByte>> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_blockingRead(handle, len.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {

              val list = ArrayList<UByte>((ptr + 8).ptr.loadInt())
              for (i in 0 until (ptr + 8).ptr.loadInt()) {
                val base = ((ptr + 4).ptr.loadInt()) + (i * 1)

                list.add((base + 0).ptr.loadUByte().toInt().toUByte())
              }

              Result<List<UByte>>.success(list)
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 8).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<List<UByte>>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Skip bytes from a stream. Returns number of bytes skipped.
     *
     * Behaves identical to `read`, except instead of returning a list of bytes, returns the number
     * of bytes consumed from the stream.
     */
    public fun skip(len: ULong): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_skip(handle, len.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 8).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 12).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<ULong>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Skip bytes from a stream, after blocking until at least one byte can be skipped. Except for
     * blocking behavior, identical to `skip`.
     */
    public fun blockingSkip(len: ULong): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_blockingSkip(handle, len.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 8).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 12).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<ULong>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Create a `pollable` which will resolve once either the specified stream has bytes available
     * to read or the other end of the stream has been closed. The created `pollable` is a child
     * resource of the `input-stream`. Implementations may trap if the `input-stream` is dropped
     * before all derived `pollable`s created with this function are dropped.
     */
    public fun subscribe(): Poll.Pollable {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_subscribe(handle)
        freeAllComponentModelReallocAllocatedMemory()
        val resource = Poll.Pollable(ResourceHandle(ret))
        return resource
      }
      // </editor-fold>
    }

    companion object {}
  }
  /**
   * An output bytestream.
   *
   * `output-stream`s are *non-blocking* to the extent practical on underlying platforms. Except
   * where specified otherwise, I/O operations also always return promptly, after the number of
   * bytes that can be written promptly, which could even be zero. To wait for the stream to be
   * ready to accept data, the `subscribe` function to obtain a `pollable` which can be polled for
   * using `wasi:io/poll`.
   */

  class OutputStream : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Streams_OutputStream_drop(__handle.value)
    }
    /**
     * Check readiness for writing. This function never blocks.
     *
     * Returns the number of bytes permitted for the next call to `write`, or an error. Calling
     * `write` with more bytes than this function has permitted will trap.
     *
     * When this function returns 0 bytes, the `subscribe` pollable will become ready when this
     * function will report at least 1 byte, or an error.
     */
    public fun checkWrite(): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_checkWrite(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 8).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 12).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<ULong>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Perform a write. This function never blocks.
     *
     * When the destination of a `write` is binary data, the bytes from `contents` are written
     * verbatim. When the destination of a `write` is known to the implementation to be text, the
     * bytes of `contents` are transcoded from UTF-8 into the encoding of the destination and then
     * written.
     *
     * Precondition: check-write gave permit of Ok(n) and contents has a length of less than or
     * equal to n. Otherwise, this function will trap.
     *
     * returns Err(closed) without writing if the stream has closed since the last call to
     * check-write provided a permit.
     */
    public fun write(contents: List<UByte>): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val address = allocator.allocate(contents.size * 1 /*, align=1*/).address.toInt()
        for ((index, el) in contents.withIndex()) {
          val base = address + (index * 1)
          (base + 0).ptr.storeByte(el.toInt().toByte())
        }
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_write(handle, address, contents.size, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 8).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<Unit>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Perform a write of up to 4096 bytes, and then flush the stream. Block until all of these
     * operations are complete, or an error occurs.
     *
     * This is a convenience wrapper around the use of `check-write`, `subscribe`, `write`, and
     * `flush`, and is implemented with the following pseudo-code:
     * ```text
     * let pollable = this.subscribe();
     * while !contents.is_empty() {
     * // Wait for the stream to become writable
     * pollable.block();
     * let Ok(n) = this.check-write(); // eliding error handling
     * let len = min(n, contents.len());
     * let (chunk, rest) = contents.split_at(len);
     * this.write(chunk  );            // eliding error handling
     * contents = rest;
     * }
     * this.flush();
     * // Wait for completion of `flush`
     * pollable.block();
     * // Check for any errors that arose during `flush`
     * let _ = this.check-write();         // eliding error handling
     * ```
     */
    public fun blockingWriteAndFlush(contents: List<UByte>): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val address = allocator.allocate(contents.size * 1 /*, align=1*/).address.toInt()
        for ((index, el) in contents.withIndex()) {
          val base = address + (index * 1)
          (base + 0).ptr.storeByte(el.toInt().toByte())
        }
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_blockingWriteAndFlush(handle, address, contents.size, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 8).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<Unit>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Request to flush buffered output. This function never blocks.
     *
     * This tells the output-stream that the caller intends any buffered output to be flushed. the
     * output which is expected to be flushed is all that has been passed to `write` prior to this
     * call.
     *
     * Upon calling this function, the `output-stream` will not accept any writes (`check-write`
     * will return `ok(0)`) until the flush has completed. The `subscribe` pollable will become
     * ready when the flush has completed and the stream can accept more writes.
     */
    public fun flush(): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_flush(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 8).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<Unit>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Request to flush buffered output, and block until flush completes and stream is ready for
     * writing again.
     */
    public fun blockingFlush(): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_blockingFlush(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 8).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<Unit>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Create a `pollable` which will resolve once the output-stream is ready for more writing, or
     * an error has occured. When this pollable is ready, `check-write` will return `ok(n)` with
     * n>0, or an error.
     *
     * If the stream is closed, this pollable is always ready immediately.
     *
     * The created `pollable` is a child resource of the `output-stream`. Implementations may trap
     * if the `output-stream` is dropped before all derived `pollable`s created with this function
     * are dropped.
     */
    public fun subscribe(): Poll.Pollable {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_subscribe0(handle)
        freeAllComponentModelReallocAllocatedMemory()
        val resource = Poll.Pollable(ResourceHandle(ret))
        return resource
      }
      // </editor-fold>
    }
    /**
     * Write zeroes to a stream.
     *
     * This should be used precisely like `write` with the exact same preconditions (must use
     * check-write first), but instead of passing a list of bytes, you simply pass the number of
     * zero-bytes that should be written.
     */
    public fun writeZeroes(len: ULong): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_writeZeroes(handle, len.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 8).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<Unit>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Perform a write of up to 4096 zeroes, and then flush the stream. Block until all of these
     * operations are complete, or an error occurs.
     *
     * This is a convenience wrapper around the use of `check-write`, `subscribe`, `write-zeroes`,
     * and `flush`, and is implemented with the following pseudo-code:
     * ```text
     * let pollable = this.subscribe();
     * while num_zeroes != 0 {
     * // Wait for the stream to become writable
     * pollable.block();
     * let Ok(n) = this.check-write(); // eliding error handling
     * let len = min(n, num_zeroes);
     * this.write-zeroes(len);         // eliding error handling
     * num_zeroes -= len;
     * }
     * this.flush();
     * // Wait for completion of `flush`
     * pollable.block();
     * // Check for any errors that arose during `flush`
     * let _ = this.check-write();         // eliding error handling
     * ```
     */
    public fun blockingWriteZeroesAndFlush(len: ULong): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_blockingWriteZeroesAndFlush(handle, len.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 8).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<Unit>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Read from one stream and write to another.
     *
     * The behavior of splice is equivelant to:
     * 1. calling `check-write` on the `output-stream`
     * 2. calling `read` on the `input-stream` with the smaller of the `check-write` permitted
     *    length and the `len` provided to `splice`
     * 3. calling `write` on the `output-stream` with that read data.
     *
     * Any error reported by the call to `check-write`, `read`, or `write` ends the splice and
     * reports that error.
     *
     * This function returns the number of bytes transferred; it may be less than `len`.
     */
    public fun splice(src: Streams.InputStream, len: ULong): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        var handle0 = src.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_splice(handle, handle0, len.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 8).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 12).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<ULong>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Read from one stream and write to another, with blocking.
     *
     * This is similar to `splice`, except that it blocks until the `output-stream` is ready for
     * writing, and the `input-stream` is ready for reading, before performing the `splice`.
     */
    public fun blockingSplice(src: Streams.InputStream, len: ULong): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        var handle0 = src.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_blockingSplice(handle, handle0, len.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              // VariantLift START.
              val variant =
                  when ((ptr + 8).ptr.loadUByte().toInt()) {
                    0 -> {
                      val resource = Error.Error(ResourceHandle((ptr + 12).ptr.loadInt()))
                      Streams.StreamError.LastOperationFailed(resource)
                    }
                    1 -> {
                      Streams.StreamError.Closed
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<ULong>.failure(ComponentException(variant))
            }
        return result
      }
      // </editor-fold>
    }

    companion object {}
  }
}

object Stdin {
  public fun getStdin(): Streams.InputStream {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Int = __wasm_import_getStdin()
      freeAllComponentModelReallocAllocatedMemory()
      val resource = Streams.InputStream(ResourceHandle(ret))
      return resource
    }
    // </editor-fold>
  }
}

object Stdout {
  public fun getStdout(): Streams.OutputStream {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Int = __wasm_import_getStdout()
      freeAllComponentModelReallocAllocatedMemory()
      val resource = Streams.OutputStream(ResourceHandle(ret))
      return resource
    }
    // </editor-fold>
  }
}

object Stderr {
  public fun getStderr(): Streams.OutputStream {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Int = __wasm_import_getStderr()
      freeAllComponentModelReallocAllocatedMemory()
      val resource = Streams.OutputStream(ResourceHandle(ret))
      return resource
    }
    // </editor-fold>
  }
}

object TerminalInput {
  /** The input side of a terminal. */
  class TerminalInput : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_TerminalInput_TerminalInput_drop(__handle.value)
    }

    companion object {}
  }
}

object TerminalOutput {
  /** The output side of a terminal. */
  class TerminalOutput : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_TerminalOutput_TerminalOutput_drop(__handle.value)
    }

    companion object {}
  }
}

object TerminalStdin {
  /**
   * If stdin is connected to a terminal, return a `terminal-input` handle allowing further
   * interaction with it.
   */
  public fun getTerminalStdin(): TerminalInput.TerminalInput? {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_getTerminalStdin(ptr)
      freeAllComponentModelReallocAllocatedMemory()
      // OptionLift start
      val option =
          if ((ptr + 0).ptr.loadUByte().toInt() == 1) {
            val resource = TerminalInput.TerminalInput(ResourceHandle((ptr + 4).ptr.loadInt()))
            resource
          } else {
            null
          }
      // OptionLift end
      return option
    }
    // </editor-fold>
  }
}

object TerminalStdout {
  /**
   * If stdout is connected to a terminal, return a `terminal-output` handle allowing further
   * interaction with it.
   */
  public fun getTerminalStdout(): TerminalOutput.TerminalOutput? {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_getTerminalStdout(ptr)
      freeAllComponentModelReallocAllocatedMemory()
      // OptionLift start
      val option =
          if ((ptr + 0).ptr.loadUByte().toInt() == 1) {
            val resource = TerminalOutput.TerminalOutput(ResourceHandle((ptr + 4).ptr.loadInt()))
            resource
          } else {
            null
          }
      // OptionLift end
      return option
    }
    // </editor-fold>
  }
}

object TerminalStderr {
  /**
   * If stderr is connected to a terminal, return a `terminal-output` handle allowing further
   * interaction with it.
   */
  public fun getTerminalStderr(): TerminalOutput.TerminalOutput? {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_getTerminalStderr(ptr)
      freeAllComponentModelReallocAllocatedMemory()
      // OptionLift start
      val option =
          if ((ptr + 0).ptr.loadUByte().toInt() == 1) {
            val resource = TerminalOutput.TerminalOutput(ResourceHandle((ptr + 4).ptr.loadInt()))
            resource
          } else {
            null
          }
      // OptionLift end
      return option
    }
    // </editor-fold>
  }
}

object MonotonicClock {
  /**
   * Read the current value of the clock.
   *
   * The clock is monotonic, therefore calling this function repeatedly will produce a sequence of
   * non-decreasing values.
   */
  public fun now(): ULong {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Long = __wasm_import_now()
      freeAllComponentModelReallocAllocatedMemory()
      return ret.toULong()
    }
    // </editor-fold>
  }
  /**
   * Query the resolution of the clock. Returns the duration of time corresponding to a clock tick.
   */
  public fun resolution(): ULong {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Long = __wasm_import_resolution()
      freeAllComponentModelReallocAllocatedMemory()
      return ret.toULong()
    }
    // </editor-fold>
  }
  /** Create a `pollable` which will resolve once the specified instant occured. */
  public fun subscribeInstant(when_: ULong): Poll.Pollable {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Int = __wasm_import_subscribeInstant(when_.toLong())
      freeAllComponentModelReallocAllocatedMemory()
      val resource = Poll.Pollable(ResourceHandle(ret))
      return resource
    }
    // </editor-fold>
  }
  /**
   * Create a `pollable` which will resolve once the given duration has elapsed, starting at the
   * time at which this function was called. occured.
   */
  public fun subscribeDuration(when_: ULong): Poll.Pollable {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Int = __wasm_import_subscribeDuration(when_.toLong())
      freeAllComponentModelReallocAllocatedMemory()
      val resource = Poll.Pollable(ResourceHandle(ret))
      return resource
    }
    // </editor-fold>
  }
}

object WallClock {

  /** A time and date in seconds plus nanoseconds. */
  data class Datetime(
      var seconds: ULong,
      var nanoseconds: UInt,
  )
  /**
   * Read the current value of the clock.
   *
   * This clock is not monotonic, therefore calling this function repeatedly will not necessarily
   * produce a sequence of non-decreasing values.
   *
   * The returned timestamps represent the number of seconds since 1970-01-01T00:00:00Z, also known
   * as [POSIX's Seconds Since the Epoch], also known as [Unix Time].
   *
   * The nanoseconds field of the output is always less than 1000000000.
   *
   * [POSIX's Seconds Since the Epoch]:
   * https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
   * [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
   */
  public fun now(): WallClock.Datetime {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
      __wasm_import_now1(ptr)
      freeAllComponentModelReallocAllocatedMemory()
      return WallClock.Datetime(
          (ptr + 0).ptr.loadLong().toULong(),
          (ptr + 8).ptr.loadInt().toUInt(),
      )
    }
    // </editor-fold>
  }
  /**
   * Query the resolution of the clock.
   *
   * The nanoseconds field of the output is always less than 1000000000.
   */
  public fun resolution(): WallClock.Datetime {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
      __wasm_import_resolution2(ptr)
      freeAllComponentModelReallocAllocatedMemory()
      return WallClock.Datetime(
          (ptr + 0).ptr.loadLong().toULong(),
          (ptr + 8).ptr.loadInt().toUInt(),
      )
    }
    // </editor-fold>
  }
}

object Types {

  /**
   * The type of a filesystem object referenced by a descriptor.
   *
   * Note: This was called `filetype` in earlier versions of WASI.
   */
  enum class DescriptorType {
    /**
     * The type of the descriptor or file is unknown or is different from any of the other types
     * specified.
     */
    UNKNOWN,
    /** The descriptor refers to a block device inode. */
    BLOCK_DEVICE,
    /** The descriptor refers to a character device inode. */
    CHARACTER_DEVICE,
    /** The descriptor refers to a directory inode. */
    DIRECTORY,
    /** The descriptor refers to a named pipe. */
    FIFO,
    /** The file refers to a symbolic link inode. */
    SYMBOLIC_LINK,
    /** The descriptor refers to a regular file inode. */
    REGULAR_FILE,
    /** The descriptor refers to a socket. */
    SOCKET,
  }

  /**
   * Descriptor flags.
   *
   * Note: This was called `fdflags` in earlier versions of WASI.
   */
  value class DescriptorFlags internal constructor(val _value: Long) {
    constructor(
        read: Boolean = false,
        write: Boolean = false,
        fileIntegritySync: Boolean = false,
        dataIntegritySync: Boolean = false,
        requestedWriteSync: Boolean = false,
        mutateDirectory: Boolean = false,
    ) : this(
        0L or
            (if (read) (1L shl 0) else 0L) or
            (if (write) (1L shl 1) else 0L) or
            (if (fileIntegritySync) (1L shl 2) else 0L) or
            (if (dataIntegritySync) (1L shl 3) else 0L) or
            (if (requestedWriteSync) (1L shl 4) else 0L) or
            (if (mutateDirectory) (1L shl 5) else 0L))

    val read: Boolean
      get() = (_value and (1L shl 0)) != 0L

    val write: Boolean
      get() = (_value and (1L shl 1)) != 0L

    val fileIntegritySync: Boolean
      get() = (_value and (1L shl 2)) != 0L

    val dataIntegritySync: Boolean
      get() = (_value and (1L shl 3)) != 0L

    val requestedWriteSync: Boolean
      get() = (_value and (1L shl 4)) != 0L

    val mutateDirectory: Boolean
      get() = (_value and (1L shl 5)) != 0L
  }

  /** Flags determining the method of how paths are resolved. */
  value class PathFlags internal constructor(val _value: Long) {
    constructor(
        symlinkFollow: Boolean = false,
    ) : this(0L or (if (symlinkFollow) (1L shl 0) else 0L))

    val symlinkFollow: Boolean
      get() = (_value and (1L shl 0)) != 0L
  }

  /** Open flags used by `open-at`. */
  value class OpenFlags internal constructor(val _value: Long) {
    constructor(
        create: Boolean = false,
        directory: Boolean = false,
        exclusive: Boolean = false,
        truncate: Boolean = false,
    ) : this(
        0L or
            (if (create) (1L shl 0) else 0L) or
            (if (directory) (1L shl 1) else 0L) or
            (if (exclusive) (1L shl 2) else 0L) or
            (if (truncate) (1L shl 3) else 0L))

    val create: Boolean
      get() = (_value and (1L shl 0)) != 0L

    val directory: Boolean
      get() = (_value and (1L shl 1)) != 0L

    val exclusive: Boolean
      get() = (_value and (1L shl 2)) != 0L

    val truncate: Boolean
      get() = (_value and (1L shl 3)) != 0L
  }

  /**
   * File attributes.
   *
   * Note: This was called `filestat` in earlier versions of WASI.
   */
  data class DescriptorStat(
      /** File type. */
      var type: Types.DescriptorType,
      /** Number of hard links to the file. */
      var linkCount: ULong,
      /**
       * For regular files, the file size in bytes. For symbolic links, the length in bytes of the
       * pathname contained in the symbolic link.
       */
      var size: ULong,
      /**
       * Last data access timestamp.
       *
       * If the `option` is none, the platform doesn't maintain an access timestamp for this file.
       */
      var dataAccessTimestamp: WallClock.Datetime?,
      /**
       * Last data modification timestamp.
       *
       * If the `option` is none, the platform doesn't maintain a modification timestamp for this
       * file.
       */
      var dataModificationTimestamp: WallClock.Datetime?,
      /**
       * Last file status-change timestamp.
       *
       * If the `option` is none, the platform doesn't maintain a status-change timestamp for this
       * file.
       */
      var statusChangeTimestamp: WallClock.Datetime?,
  )

  /** When setting a timestamp, this gives the value to set it to. */
  sealed interface NewTimestamp {
    data object NoChange : NewTimestamp

    data object Now : NewTimestamp

    data class Timestamp(val value: WallClock.Datetime) : NewTimestamp
  }
  /** A directory entry. */
  data class DirectoryEntry(
      /** The type of the file referred to by this directory entry. */
      var type: Types.DescriptorType,
      /** The name of the object. */
      var name: String,
  )

  /**
   * Error codes returned by functions, similar to `errno` in POSIX. Not all of these error codes
   * are returned by the functions provided by this API; some are used in higher-level library
   * layers, and others are provided merely for alignment with POSIX.
   */
  enum class ErrorCode {
    /** Permission denied, similar to `EACCES` in POSIX. */
    ACCESS,
    /**
     * Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in
     * POSIX.
     */
    WOULD_BLOCK,
    /** Connection already in progress, similar to `EALREADY` in POSIX. */
    ALREADY,
    /** Bad descriptor, similar to `EBADF` in POSIX. */
    BAD_DESCRIPTOR,
    /** Device or resource busy, similar to `EBUSY` in POSIX. */
    BUSY,
    /** Resource deadlock would occur, similar to `EDEADLK` in POSIX. */
    DEADLOCK,
    /** Storage quota exceeded, similar to `EDQUOT` in POSIX. */
    QUOTA,
    /** File exists, similar to `EEXIST` in POSIX. */
    EXIST,
    /** File too large, similar to `EFBIG` in POSIX. */
    FILE_TOO_LARGE,
    /** Illegal byte sequence, similar to `EILSEQ` in POSIX. */
    ILLEGAL_BYTE_SEQUENCE,
    /** Operation in progress, similar to `EINPROGRESS` in POSIX. */
    IN_PROGRESS,
    /** Interrupted function, similar to `EINTR` in POSIX. */
    INTERRUPTED,
    /** Invalid argument, similar to `EINVAL` in POSIX. */
    INVALID,
    /** I/O error, similar to `EIO` in POSIX. */
    IO,
    /** Is a directory, similar to `EISDIR` in POSIX. */
    IS_DIRECTORY,
    /** Too many levels of symbolic links, similar to `ELOOP` in POSIX. */
    LOOP,
    /** Too many links, similar to `EMLINK` in POSIX. */
    TOO_MANY_LINKS,
    /** Message too large, similar to `EMSGSIZE` in POSIX. */
    MESSAGE_SIZE,
    /** Filename too long, similar to `ENAMETOOLONG` in POSIX. */
    NAME_TOO_LONG,
    /** No such device, similar to `ENODEV` in POSIX. */
    NO_DEVICE,
    /** No such file or directory, similar to `ENOENT` in POSIX. */
    NO_ENTRY,
    /** No locks available, similar to `ENOLCK` in POSIX. */
    NO_LOCK,
    /** Not enough space, similar to `ENOMEM` in POSIX. */
    INSUFFICIENT_MEMORY,
    /** No space left on device, similar to `ENOSPC` in POSIX. */
    INSUFFICIENT_SPACE,
    /** Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX. */
    NOT_DIRECTORY,
    /** Directory not empty, similar to `ENOTEMPTY` in POSIX. */
    NOT_EMPTY,
    /** State not recoverable, similar to `ENOTRECOVERABLE` in POSIX. */
    NOT_RECOVERABLE,
    /** Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX. */
    UNSUPPORTED,
    /** Inappropriate I/O control operation, similar to `ENOTTY` in POSIX. */
    NO_TTY,
    /** No such device or address, similar to `ENXIO` in POSIX. */
    NO_SUCH_DEVICE,
    /** Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX. */
    OVERFLOW,
    /** Operation not permitted, similar to `EPERM` in POSIX. */
    NOT_PERMITTED,
    /** Broken pipe, similar to `EPIPE` in POSIX. */
    PIPE,
    /** Read-only file system, similar to `EROFS` in POSIX. */
    READ_ONLY,
    /** Invalid seek, similar to `ESPIPE` in POSIX. */
    INVALID_SEEK,
    /** Text file busy, similar to `ETXTBSY` in POSIX. */
    TEXT_FILE_BUSY,
    /** Cross-device link, similar to `EXDEV` in POSIX. */
    CROSS_DEVICE,
  }

  /** File or memory access pattern advisory information. */
  enum class Advice {
    /** The application has no advice to give on its behavior with respect to the specified data. */
    NORMAL,
    /**
     * The application expects to access the specified data sequentially from lower offsets to
     * higher offsets.
     */
    SEQUENTIAL,
    /** The application expects to access the specified data in a random order. */
    RANDOM,
    /** The application expects to access the specified data in the near future. */
    WILL_NEED,
    /** The application expects that it will not access the specified data in the near future. */
    DONT_NEED,
    /**
     * The application expects to access the specified data once and then not reuse it thereafter.
     */
    NO_REUSE,
  }

  /** A 128-bit hash value, split into parts because wasm doesn't have a 128-bit integer type. */
  data class MetadataHashValue(
      /** 64 bits of a 128-bit hash value. */
      var lower: ULong,
      /** Another 64 bits of a 128-bit hash value. */
      var upper: ULong,
  )
  /**
   * A descriptor is a reference to a filesystem object, which may be a file, directory, named pipe,
   * special file, or other object on which filesystem calls may be made.
   */
  class Descriptor : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Types_Descriptor_drop(__handle.value)
    }
    /**
     * Return a stream for reading from a file, if available.
     *
     * May fail with an error-code describing why the file cannot be read.
     *
     * Multiple read, write, and append streams may be active on the same open file and they do not
     * interfere with each other.
     *
     * Note: This allows using `read-stream`, which is similar to `read` in POSIX.
     */
    public fun readViaStream(offset: ULong): Result<Streams.InputStream> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
        __wasm_import_readViaStream(handle, offset.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              val resource = Streams.InputStream(ResourceHandle((ptr + 4).ptr.loadInt()))

              Result<Streams.InputStream>.success(resource)
            } else {
              Result<Streams.InputStream>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Return a stream for writing to a file, if available.
     *
     * May fail with an error-code describing why the file cannot be written.
     *
     * Note: This allows using `write-stream`, which is similar to `write` in POSIX.
     */
    public fun writeViaStream(offset: ULong): Result<Streams.OutputStream> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
        __wasm_import_writeViaStream(handle, offset.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              val resource = Streams.OutputStream(ResourceHandle((ptr + 4).ptr.loadInt()))

              Result<Streams.OutputStream>.success(resource)
            } else {
              Result<Streams.OutputStream>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Return a stream for appending to a file, if available.
     *
     * May fail with an error-code describing why the file cannot be appended.
     *
     * Note: This allows using `write-stream`, which is similar to `write` with `O_APPEND` in in
     * POSIX.
     */
    public fun appendViaStream(): Result<Streams.OutputStream> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
        __wasm_import_appendViaStream(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              val resource = Streams.OutputStream(ResourceHandle((ptr + 4).ptr.loadInt()))

              Result<Streams.OutputStream>.success(resource)
            } else {
              Result<Streams.OutputStream>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Provide file advisory information on a descriptor.
     *
     * This is similar to `posix_fadvise` in POSIX.
     */
    public fun advise(offset: ULong, length: ULong, advice: Types.Advice): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_advise(handle, offset.toLong(), length.toLong(), advice.ordinal, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Synchronize the data of a file to disk.
     *
     * This function succeeds with no effect if the file descriptor is not opened for writing.
     *
     * Note: This is similar to `fdatasync` in POSIX.
     */
    public fun syncData(): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_syncData(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Get flags associated with a descriptor.
     *
     * Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
     *
     * Note: This returns the value that was the `fs_flags` value returned from `fdstat_get` in
     * earlier versions of WASI.
     */
    public fun getFlags(): Result<Types.DescriptorFlags> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_getFlags(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Types.DescriptorFlags>
                  .success(Types.DescriptorFlags((ptr + 1).ptr.loadUByte().toInt().toLong()))
            } else {
              Result<Types.DescriptorFlags>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Get the dynamic type of a descriptor.
     *
     * Note: This returns the same value as the `type` field of the `fd-stat` returned by `stat`,
     * `stat-at` and similar.
     *
     * Note: This returns similar flags to the `st_mode & S_IFMT` value provided by `fstat` in
     * POSIX.
     *
     * Note: This returns the value that was the `fs_filetype` value returned from `fdstat_get` in
     * earlier versions of WASI.
     */
    public fun getType(): Result<Types.DescriptorType> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_getType(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Types.DescriptorType>
                  .success(Types.DescriptorType.values()[(ptr + 1).ptr.loadUByte().toInt()])
            } else {
              Result<Types.DescriptorType>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Adjust the size of an open file. If this increases the file's size, the extra bytes are
     * filled with zeros.
     *
     * Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
     */
    public fun setSize(size: ULong): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setSize(handle, size.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Adjust the timestamps of an open file or directory.
     *
     * Note: This is similar to `futimens` in POSIX.
     *
     * Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
     */
    public fun setTimes(
        dataAccessTimestamp: Types.NewTimestamp,
        dataModificationTimestamp: Types.NewTimestamp
    ): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        // VariantLower START
        val variant: Int
        val variant2: Long
        val variant3: Int
        when (val x = dataAccessTimestamp) {
          is Types.NewTimestamp.NoChange -> {
            variant = 0
            variant2 = 0L
            variant3 = 0
          }
          is Types.NewTimestamp.Now -> {
            variant = 1
            variant2 = 0L
            variant3 = 0
          }
          is Types.NewTimestamp.Timestamp -> {
            val payload1 = x.value
            variant = 2
            variant2 = payload1.seconds.toLong()
            variant3 = payload1.nanoseconds.toInt()
          }
          else -> error("unreachable")
        }
        // VariantLower END
        // VariantLower START
        val variant7: Int
        val variant8: Long
        val variant9: Int
        when (val x10 = dataModificationTimestamp) {
          is Types.NewTimestamp.NoChange -> {
            variant7 = 0
            variant8 = 0L
            variant9 = 0
          }
          is Types.NewTimestamp.Now -> {
            variant7 = 1
            variant8 = 0L
            variant9 = 0
          }
          is Types.NewTimestamp.Timestamp -> {
            val payload6 = x10.value
            variant7 = 2
            variant8 = payload6.seconds.toLong()
            variant9 = payload6.nanoseconds.toInt()
          }
          else -> error("unreachable")
        }
        // VariantLower END
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setTimes(
            handle, variant, variant2, variant3, variant7, variant8, variant9, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Read from a descriptor, without using and updating the descriptor's offset.
     *
     * This function returns a list of bytes containing the data that was read, along with a bool
     * which, when true, indicates that the end of the file was reached. The returned list will
     * contain up to `length` bytes; it may return fewer than requested, if the end of the file is
     * reached or if the I/O operation is interrupted.
     *
     * In the future, this may change to return a `stream<u8, error-code>`.
     *
     * Note: This is similar to `pread` in POSIX.
     */
    public fun read(length: ULong, offset: ULong): Result<Pair<List<UByte>, Boolean>> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=4)*/ allocator.allocate(16).address.toInt()
        __wasm_import_read3(handle, length.toLong(), offset.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {

              val list = ArrayList<UByte>((ptr + 8).ptr.loadInt())
              for (i in 0 until (ptr + 8).ptr.loadInt()) {
                val base = ((ptr + 4).ptr.loadInt()) + (i * 1)

                list.add((base + 0).ptr.loadUByte().toInt().toUByte())
              }

              Result<Pair<List<UByte>, Boolean>>
                  .success(
                      Pair<List<UByte>, Boolean>(
                          list,
                          ((ptr + 12).ptr.loadUByte().toInt() != 0),
                      ))
            } else {
              Result<Pair<List<UByte>, Boolean>>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Write to a descriptor, without using and updating the descriptor's offset.
     *
     * It is valid to write past the end of a file; the file is extended to the extent of the write,
     * with bytes between the previous end and the start of the write set to zero.
     *
     * In the future, this may change to take a `stream<u8, error-code>`.
     *
     * Note: This is similar to `pwrite` in POSIX.
     */
    public fun write(buffer: List<UByte>, offset: ULong): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val address = allocator.allocate(buffer.size * 1 /*, align=1*/).address.toInt()
        for ((index, el) in buffer.withIndex()) {
          val base = address + (index * 1)
          (base + 0).ptr.storeByte(el.toInt().toByte())
        }
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_write4(handle, address, buffer.size, offset.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              Result<ULong>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Read directory entries from a directory.
     *
     * On filesystems where directories contain entries referring to themselves and their parents,
     * often named `.` and `..` respectively, these entries are omitted.
     *
     * This always returns a new stream which starts at the beginning of the directory. Multiple
     * streams may be active on the same directory, and they do not interfere with each other.
     */
    public fun readDirectory(): Result<Types.DirectoryEntryStream> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
        __wasm_import_readDirectory(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              val resource = Types.DirectoryEntryStream(ResourceHandle((ptr + 4).ptr.loadInt()))

              Result<Types.DirectoryEntryStream>.success(resource)
            } else {
              Result<Types.DirectoryEntryStream>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Synchronize the data and metadata of a file to disk.
     *
     * This function succeeds with no effect if the file descriptor is not opened for writing.
     *
     * Note: This is similar to `fsync` in POSIX.
     */
    public fun sync(): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_sync(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Create a directory.
     *
     * Note: This is similar to `mkdirat` in POSIX.
     */
    public fun createDirectoryAt(path: String): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = path.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        val ptr0 = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_createDirectoryAt(handle, ptr, len, ptr0)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr0 + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr0 + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Return the attributes of an open file or directory.
     *
     * Note: This is similar to `fstat` in POSIX, except that it does not return device and inode
     * information. For testing whether two descriptors refer to the same underlying filesystem
     * object, use `is-same-object`. To obtain additional data that can be used do determine whether
     * a file has been modified, use `metadata-hash`.
     *
     * Note: This was called `fd_filestat_get` in earlier versions of WASI.
     */
    public fun stat(): Result<Types.DescriptorStat> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=104, align=8)*/
            allocator.allocate(104).address.toInt()
        __wasm_import_stat(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              // OptionLift start
              val option =
                  if ((ptr + 32).ptr.loadUByte().toInt() == 1) {
                    WallClock.Datetime(
                        (ptr + 40).ptr.loadLong().toULong(),
                        (ptr + 48).ptr.loadInt().toUInt(),
                    )
                  } else {
                    null
                  }
              // OptionLift end
              // OptionLift start
              val option0 =
                  if ((ptr + 56).ptr.loadUByte().toInt() == 1) {
                    WallClock.Datetime(
                        (ptr + 64).ptr.loadLong().toULong(),
                        (ptr + 72).ptr.loadInt().toUInt(),
                    )
                  } else {
                    null
                  }
              // OptionLift end
              // OptionLift start
              val option1 =
                  if ((ptr + 80).ptr.loadUByte().toInt() == 1) {
                    WallClock.Datetime(
                        (ptr + 88).ptr.loadLong().toULong(),
                        (ptr + 96).ptr.loadInt().toUInt(),
                    )
                  } else {
                    null
                  }
              // OptionLift end

              Result<Types.DescriptorStat>
                  .success(
                      Types.DescriptorStat(
                          Types.DescriptorType.values()[(ptr + 8).ptr.loadUByte().toInt()],
                          (ptr + 16).ptr.loadLong().toULong(),
                          (ptr + 24).ptr.loadLong().toULong(),
                          option,
                          option0,
                          option1,
                      ))
            } else {
              Result<Types.DescriptorStat>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Return the attributes of a file or directory.
     *
     * Note: This is similar to `fstatat` in POSIX, except that it does not return device and inode
     * information. See the `stat` description for a discussion of alternatives.
     *
     * Note: This was called `path_filestat_get` in earlier versions of WASI.
     */
    public fun statAt(pathFlags: Types.PathFlags, path: String): Result<Types.DescriptorStat> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = path.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        val ptr0 = /* RETURN_ADDRESS_ALLOC(size=104, align=8)*/
            allocator.allocate(104).address.toInt()
        __wasm_import_statAt(handle, pathFlags._value.toInt(), ptr, len, ptr0)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr0 + 0).ptr.loadUByte().toInt() == 0) {
              // OptionLift start
              val option =
                  if ((ptr0 + 32).ptr.loadUByte().toInt() == 1) {
                    WallClock.Datetime(
                        (ptr0 + 40).ptr.loadLong().toULong(),
                        (ptr0 + 48).ptr.loadInt().toUInt(),
                    )
                  } else {
                    null
                  }
              // OptionLift end
              // OptionLift start
              val option1 =
                  if ((ptr0 + 56).ptr.loadUByte().toInt() == 1) {
                    WallClock.Datetime(
                        (ptr0 + 64).ptr.loadLong().toULong(),
                        (ptr0 + 72).ptr.loadInt().toUInt(),
                    )
                  } else {
                    null
                  }
              // OptionLift end
              // OptionLift start
              val option2 =
                  if ((ptr0 + 80).ptr.loadUByte().toInt() == 1) {
                    WallClock.Datetime(
                        (ptr0 + 88).ptr.loadLong().toULong(),
                        (ptr0 + 96).ptr.loadInt().toUInt(),
                    )
                  } else {
                    null
                  }
              // OptionLift end

              Result<Types.DescriptorStat>
                  .success(
                      Types.DescriptorStat(
                          Types.DescriptorType.values()[(ptr0 + 8).ptr.loadUByte().toInt()],
                          (ptr0 + 16).ptr.loadLong().toULong(),
                          (ptr0 + 24).ptr.loadLong().toULong(),
                          option,
                          option1,
                          option2,
                      ))
            } else {
              Result<Types.DescriptorStat>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr0 + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Adjust the timestamps of a file or directory.
     *
     * Note: This is similar to `utimensat` in POSIX.
     *
     * Note: This was called `path_filestat_set_times` in earlier versions of WASI.
     */
    public fun setTimesAt(
        pathFlags: Types.PathFlags,
        path: String,
        dataAccessTimestamp: Types.NewTimestamp,
        dataModificationTimestamp: Types.NewTimestamp
    ): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = path.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        // VariantLower START
        val variant: Int
        val variant2: Long
        val variant3: Int
        when (val x = dataAccessTimestamp) {
          is Types.NewTimestamp.NoChange -> {
            variant = 0
            variant2 = 0L
            variant3 = 0
          }
          is Types.NewTimestamp.Now -> {
            variant = 1
            variant2 = 0L
            variant3 = 0
          }
          is Types.NewTimestamp.Timestamp -> {
            val payload1 = x.value
            variant = 2
            variant2 = payload1.seconds.toLong()
            variant3 = payload1.nanoseconds.toInt()
          }
          else -> error("unreachable")
        }
        // VariantLower END
        // VariantLower START
        val variant7: Int
        val variant8: Long
        val variant9: Int
        when (val x10 = dataModificationTimestamp) {
          is Types.NewTimestamp.NoChange -> {
            variant7 = 0
            variant8 = 0L
            variant9 = 0
          }
          is Types.NewTimestamp.Now -> {
            variant7 = 1
            variant8 = 0L
            variant9 = 0
          }
          is Types.NewTimestamp.Timestamp -> {
            val payload6 = x10.value
            variant7 = 2
            variant8 = payload6.seconds.toLong()
            variant9 = payload6.nanoseconds.toInt()
          }
          else -> error("unreachable")
        }
        // VariantLower END
        val ptr11 = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setTimesAt(
            handle,
            pathFlags._value.toInt(),
            ptr,
            len,
            variant,
            variant2,
            variant3,
            variant7,
            variant8,
            variant9,
            ptr11)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr11 + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr11 + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Create a hard link.
     *
     * Note: This is similar to `linkat` in POSIX.
     */
    public fun linkAt(
        oldPathFlags: Types.PathFlags,
        oldPath: String,
        newDescriptor: Types.Descriptor,
        newPath: String
    ): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = oldPath.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        var handle0 = newDescriptor.__handle.value

        val bytearray3 = newPath.encodeToByteArray()
        val len2 = bytearray3.size
        val ptr1 = allocator.writeToLinearMemory(bytearray3).address.toInt()

        val ptr4 = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_linkAt(
            handle, oldPathFlags._value.toInt(), ptr, len, handle0, ptr1, len2, ptr4)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr4 + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr4 + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Open a file or directory.
     *
     * The returned descriptor is not guaranteed to be the lowest-numbered descriptor not currently
     * open/ it is randomized to prevent applications from depending on making assumptions about
     * indexes, since this is error-prone in multi-threaded contexts. The returned descriptor is
     * guaranteed to be less than 2**31.
     *
     * If `flags` contains `descriptor-flags::mutate-directory`, and the base descriptor doesn't
     * have `descriptor-flags::mutate-directory` set, `open-at` fails with `error-code::read-only`.
     *
     * If `flags` contains `write` or `mutate-directory`, or `open-flags` contains `truncate` or
     * `create`, and the base descriptor doesn't have `descriptor-flags::mutate-directory` set,
     * `open-at` fails with `error-code::read-only`.
     *
     * Note: This is similar to `openat` in POSIX.
     */
    public fun openAt(
        pathFlags: Types.PathFlags,
        path: String,
        openFlags: Types.OpenFlags,
        flags: Types.DescriptorFlags
    ): Result<Types.Descriptor> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = path.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        val ptr0 = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
        __wasm_import_openAt(
            handle,
            pathFlags._value.toInt(),
            ptr,
            len,
            openFlags._value.toInt(),
            flags._value.toInt(),
            ptr0)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr0 + 0).ptr.loadUByte().toInt() == 0) {
              val resource = Types.Descriptor(ResourceHandle((ptr0 + 4).ptr.loadInt()))

              Result<Types.Descriptor>.success(resource)
            } else {
              Result<Types.Descriptor>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr0 + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Read the contents of a symbolic link.
     *
     * If the contents contain an absolute or rooted path in the underlying filesystem, this
     * function fails with `error-code::not-permitted`.
     *
     * Note: This is similar to `readlinkat` in POSIX.
     */
    public fun readlinkAt(path: String): Result<String> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = path.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        val ptr0 = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/
            allocator.allocate(12).address.toInt()
        __wasm_import_readlinkAt(handle, ptr, len, ptr0)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr0 + 0).ptr.loadUByte().toInt() == 0) {
              Result<String>
                  .success(STRING_FROM_MEM((ptr0 + 4).ptr.loadInt(), (ptr0 + 8).ptr.loadInt()))
            } else {
              Result<String>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr0 + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Remove a directory.
     *
     * Return `error-code::not-empty` if the directory is not empty.
     *
     * Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
     */
    public fun removeDirectoryAt(path: String): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = path.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        val ptr0 = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_removeDirectoryAt(handle, ptr, len, ptr0)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr0 + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr0 + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Rename a filesystem object.
     *
     * Note: This is similar to `renameat` in POSIX.
     */
    public fun renameAt(
        oldPath: String,
        newDescriptor: Types.Descriptor,
        newPath: String
    ): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = oldPath.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        var handle0 = newDescriptor.__handle.value

        val bytearray3 = newPath.encodeToByteArray()
        val len2 = bytearray3.size
        val ptr1 = allocator.writeToLinearMemory(bytearray3).address.toInt()

        val ptr4 = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_renameAt(handle, ptr, len, handle0, ptr1, len2, ptr4)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr4 + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr4 + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Create a symbolic link (also known as a "symlink").
     *
     * If `old-path` starts with `/`, the function fails with `error-code::not-permitted`.
     *
     * Note: This is similar to `symlinkat` in POSIX.
     */
    public fun symlinkAt(oldPath: String, newPath: String): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = oldPath.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        val bytearray2 = newPath.encodeToByteArray()
        val len1 = bytearray2.size
        val ptr0 = allocator.writeToLinearMemory(bytearray2).address.toInt()

        val ptr3 = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_symlinkAt(handle, ptr, len, ptr0, len1, ptr3)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr3 + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr3 + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Unlink a filesystem object that is not a directory.
     *
     * Return `error-code::is-directory` if the path refers to a directory. Note: This is similar to
     * `unlinkat(fd, path, 0)` in POSIX.
     */
    public fun unlinkFileAt(path: String): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = path.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        val ptr0 = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_unlinkFileAt(handle, ptr, len, ptr0)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr0 + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr0 + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Test whether two descriptors refer to the same filesystem object.
     *
     * In POSIX, this corresponds to testing whether the two descriptors have the same device
     * (`st_dev`) and inode (`st_ino` or `d_ino`) numbers. wasi-filesystem does not expose device
     * and inode numbers, so this function may be used instead.
     */
    public fun isSameObject(other: Types.Descriptor): Boolean {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        var handle0 = other.__handle.value
        val ret: Int = __wasm_import_isSameObject(handle, handle0)
        freeAllComponentModelReallocAllocatedMemory()
        return (ret != 0)
      }
      // </editor-fold>
    }
    /**
     * Return a hash of the metadata associated with a filesystem object referred to by a
     * descriptor.
     *
     * This returns a hash of the last-modification timestamp and file size, and may also include
     * the inode number, device number, birth timestamp, and other metadata fields that may change
     * when the file is modified or replaced. It may also include a secret value chosen by the
     * implementation and not otherwise exposed.
     *
     * Implementations are encourated to provide the following properties:
     * - If the file is not modified or replaced, the computed hash value should usually not change.
     * - If the object is modified or replaced, the computed hash value should usually change.
     * - The inputs to the hash should not be easily computable from the computed hash.
     *
     * However, none of these is required.
     */
    public fun metadataHash(): Result<Types.MetadataHashValue> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=24, align=8)*/ allocator.allocate(24).address.toInt()
        __wasm_import_metadataHash(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Types.MetadataHashValue>
                  .success(
                      Types.MetadataHashValue(
                          (ptr + 8).ptr.loadLong().toULong(),
                          (ptr + 16).ptr.loadLong().toULong(),
                      ))
            } else {
              Result<Types.MetadataHashValue>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Return a hash of the metadata associated with a filesystem object referred to by a directory
     * descriptor and a relative path.
     *
     * This performs the same hash computation as `metadata-hash`.
     */
    public fun metadataHashAt(
        pathFlags: Types.PathFlags,
        path: String
    ): Result<Types.MetadataHashValue> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val bytearray = path.encodeToByteArray()
        val len = bytearray.size
        val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

        val ptr0 = /* RETURN_ADDRESS_ALLOC(size=24, align=8)*/
            allocator.allocate(24).address.toInt()
        __wasm_import_metadataHashAt(handle, pathFlags._value.toInt(), ptr, len, ptr0)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr0 + 0).ptr.loadUByte().toInt() == 0) {
              Result<Types.MetadataHashValue>
                  .success(
                      Types.MetadataHashValue(
                          (ptr0 + 8).ptr.loadLong().toULong(),
                          (ptr0 + 16).ptr.loadLong().toULong(),
                      ))
            } else {
              Result<Types.MetadataHashValue>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr0 + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    companion object {}
  }
  /** A stream of directory entries. */

  class DirectoryEntryStream : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Types_DirectoryEntryStream_drop(__handle.value)
    }
    /** Read a single directory entry from a `directory-entry-stream`. */
    public fun readDirectoryEntry(): Result<Types.DirectoryEntry?> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=20, align=4)*/ allocator.allocate(20).address.toInt()
        __wasm_import_readDirectoryEntry(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              // OptionLift start
              val option =
                  if ((ptr + 4).ptr.loadUByte().toInt() == 1) {
                    Types.DirectoryEntry(
                        Types.DescriptorType.values()[(ptr + 8).ptr.loadUByte().toInt()],
                        STRING_FROM_MEM((ptr + 12).ptr.loadInt(), (ptr + 16).ptr.loadInt()),
                    )
                  } else {
                    null
                  }
              // OptionLift end

              Result<Types.DirectoryEntry?>.success(option)
            } else {
              Result<Types.DirectoryEntry?>
                  .failure(
                      ComponentException(
                          Types.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    companion object {}
  }
  /**
   * Attempts to extract a filesystem-related `error-code` from the stream `error` provided.
   *
   * Stream operations which return `stream-error::last-operation-failed` have a payload with more
   * information about the operation that failed. This payload can be passed through to this
   * function to see if there's filesystem-related information about the error to return.
   *
   * Note that this function is fallible because not all stream-related errors are
   * filesystem-related errors.
   */

  public fun filesystemErrorCode(err_: Error.Error): Types.ErrorCode? {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      var handle = err_.__handle.value
      val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
      __wasm_import_filesystemErrorCode(handle, ptr)
      freeAllComponentModelReallocAllocatedMemory()
      // OptionLift start
      val option =
          if ((ptr + 0).ptr.loadUByte().toInt() == 1) {
            Types.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]
          } else {
            null
          }
      // OptionLift end
      return option
    }
    // </editor-fold>
  }
}

object Preopens {
  /** Return the set of preopened directories, and their path. */
  public fun getDirectories(): List<Pair<Types.Descriptor, String>> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_getDirectories(ptr)
      freeAllComponentModelReallocAllocatedMemory()

      val list = ArrayList<Pair<Types.Descriptor, String>>((ptr + 4).ptr.loadInt())
      for (i in 0 until (ptr + 4).ptr.loadInt()) {
        val base = ((ptr + 0).ptr.loadInt()) + (i * 12)
        val resource = Types.Descriptor(ResourceHandle((base + 0).ptr.loadInt()))

        list.add(
            Pair<Types.Descriptor, String>(
                resource,
                STRING_FROM_MEM((base + 4).ptr.loadInt(), (base + 8).ptr.loadInt()),
            ))
      }
      return list
    }
    // </editor-fold>
  }
}

object Network {
  /**
   * An opaque resource that represents access to (a subset of) the network. This enables
   * context-based security for networking. There is no need for this to map 1:1 to a physical
   * network interface.
   */
  class Network : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Network_Network_drop(__handle.value)
    }

    companion object {}
  }
  /**
   * Error codes.
   *
   * In theory, every API can return any error code. In practice, API's typically only return the
   * errors documented per API combined with a couple of errors that are always possible:
   * - `unknown`
   * - `access-denied`
   * - `not-supported`
   * - `out-of-memory`
   * - `concurrency-conflict`
   *
   * See each individual API for what the POSIX equivalents are. They sometimes differ per API.
   */
  enum class ErrorCode {
    /** Unknown error */
    UNKNOWN,
    /**
     * Access denied.
     *
     * POSIX equivalent: EACCES, EPERM
     */
    ACCESS_DENIED,
    /**
     * The operation is not supported.
     *
     * POSIX equivalent: EOPNOTSUPP
     */
    NOT_SUPPORTED,
    /**
     * One of the arguments is invalid.
     *
     * POSIX equivalent: EINVAL
     */
    INVALID_ARGUMENT,
    /**
     * Not enough memory to complete the operation.
     *
     * POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY
     */
    OUT_OF_MEMORY,
    /** The operation timed out before it could finish completely. */
    TIMEOUT,
    /**
     * This operation is incompatible with another asynchronous operation that is already in
     * progress.
     *
     * POSIX equivalent: EALREADY
     */
    CONCURRENCY_CONFLICT,
    /**
     * Trying to finish an asynchronous operation that:
     * - has not been started yet, or:
     * - was already finished by a previous `finish-*` call.
     *
     * Note: this is scheduled to be removed when `future`s are natively supported.
     */
    NOT_IN_PROGRESS,
    /**
     * The operation has been aborted because it could not be completed immediately.
     *
     * Note: this is scheduled to be removed when `future`s are natively supported.
     */
    WOULD_BLOCK,
    /** The operation is not valid in the socket's current state. */
    INVALID_STATE,
    /** A new socket resource could not be created because of a system limit. */
    NEW_SOCKET_LIMIT,
    /**
     * A bind operation failed because the provided address is not an address that the `network` can
     * bind to.
     */
    ADDRESS_NOT_BINDABLE,
    /**
     * A bind operation failed because the provided address is already in use or because there are
     * no ephemeral ports available.
     */
    ADDRESS_IN_USE,
    /** The remote address is not reachable */
    REMOTE_UNREACHABLE,
    /** The TCP connection was forcefully rejected */
    CONNECTION_REFUSED,
    /** The TCP connection was reset. */
    CONNECTION_RESET,
    /** A TCP connection was aborted. */
    CONNECTION_ABORTED,
    /** The size of a datagram sent to a UDP socket exceeded the maximum supported size. */
    DATAGRAM_TOO_LARGE,
    /** Name does not exist or has no suitable associated IP addresses. */
    NAME_UNRESOLVABLE,
    /** A temporary failure in name resolution occurred. */
    TEMPORARY_RESOLVER_FAILURE,
    /** A permanent failure in name resolution occurred. */
    PERMANENT_RESOLVER_FAILURE,
  }

  enum class IpAddressFamily {
    /** Similar to `AF_INET` in POSIX. */
    IPV4,
    /** Similar to `AF_INET6` in POSIX. */
    IPV6,
  }

  sealed interface IpAddress {
    data class Ipv4(val value: Tuple4<UByte, UByte, UByte, UByte>) : IpAddress

    data class Ipv6(
        val value: Tuple8<UShort, UShort, UShort, UShort, UShort, UShort, UShort, UShort>
    ) : IpAddress
  }

  data class Ipv4SocketAddress(
      /** sin_port */
      var port: UShort,
      /** sin_addr */
      var address: Tuple4<UByte, UByte, UByte, UByte>,
  )

  data class Ipv6SocketAddress(
      /** sin6_port */
      var port: UShort,
      /** sin6_flowinfo */
      var flowInfo: UInt,
      /** sin6_addr */
      var address: Tuple8<UShort, UShort, UShort, UShort, UShort, UShort, UShort, UShort>,
      /** sin6_scope_id */
      var scopeId: UInt,
  )

  sealed interface IpSocketAddress {
    data class Ipv4(val value: Network.Ipv4SocketAddress) : IpSocketAddress

    data class Ipv6(val value: Network.Ipv6SocketAddress) : IpSocketAddress
  }
}

object InstanceNetwork {
  /** Get a handle to the default network. */
  public fun instanceNetwork(): Network.Network {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Int = __wasm_import_instanceNetwork()
      freeAllComponentModelReallocAllocatedMemory()
      val resource = Network.Network(ResourceHandle(ret))
      return resource
    }
    // </editor-fold>
  }
}

object Udp {

  /** A received datagram. */
  data class IncomingDatagram(
      /**
       * The payload.
       *
       * Theoretical max size: ~64 KiB. In practice, typically less than 1500 bytes.
       */
      var data: List<UByte>,
      /**
       * The source address.
       *
       * This field is guaranteed to match the remote address the stream was initialized with, if
       * any.
       *
       * Equivalent to the `src_addr` out parameter of `recvfrom`.
       */
      var remoteAddress: Network.IpSocketAddress,
  )

  /** A datagram to be sent out. */
  data class OutgoingDatagram(
      /** The payload. */
      var data: List<UByte>,
      /**
       * The destination address.
       *
       * The requirements on this field depend on how the stream was initialized:
       * - with a remote address: this field must be None or match the stream's remote address
       *   exactly.
       * - without a remote address: this field is required.
       *
       * If this value is None, the send operation is equivalent to `send` in POSIX. Otherwise it is
       * equivalent to `sendto`.
       */
      var remoteAddress: Network.IpSocketAddress?,
  )
  /** A UDP socket handle. */
  class UdpSocket : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Udp_UdpSocket_drop(__handle.value)
    }
    /**
     * Bind the socket to a specific network on the provided IP address and port.
     *
     * If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation
     * to decide which network interface(s) to bind to. If the port is zero, the socket will be
     * bound to a random free port.
     *
     * # Typical errors
     * - `invalid-argument`: The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT
     *   on Windows)
     * - `invalid-state`: The socket is already bound. (EINVAL)
     * - `address-in-use`: No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
     * - `address-in-use`: Address is already in use. (EADDRINUSE)
     * - `address-not-bindable`: `local-address` is not an address that the `network` can bind to.
     *   (EADDRNOTAVAIL)
     * - `not-in-progress`: A `bind` operation is not in progress.
     * - `would-block`: Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
     *
     * # Implementors note
     * Unlike in POSIX, in WASI the bind operation is async. This enables interactive WASI hosts to
     * inject permission prompts. Runtimes that don't want to make use of this ability can simply
     * call the native `bind` as part of either `start-bind` or `finish-bind`.
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
     * - <https://man7.org/linux/man-pages/man2/bind.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
     * - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
     */
    public fun startBind(
        network: Network.Network,
        localAddress: Network.IpSocketAddress
    ): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        var handle0 = network.__handle.value
        // VariantLower START
        val variant: Int
        val variant2: Int
        val variant3: Int
        val variant4: Int
        val variant5: Int
        val variant6: Int
        val variant7: Int
        val variant8: Int
        val variant9: Int
        val variant10: Int
        val variant11: Int
        val variant12: Int
        when (val x = localAddress) {
          is Network.IpSocketAddress.Ipv4 -> {
            val payload = x.value
            variant = 0
            variant2 = payload.port.toInt()
            variant3 = payload.address.f0.toInt()
            variant4 = payload.address.f1.toInt()
            variant5 = payload.address.f2.toInt()
            variant6 = payload.address.f3.toInt()
            variant7 = 0
            variant8 = 0
            variant9 = 0
            variant10 = 0
            variant11 = 0
            variant12 = 0
          }
          is Network.IpSocketAddress.Ipv6 -> {
            val payload1 = x.value
            variant = 1
            variant2 = payload1.port.toInt()
            variant3 = payload1.flowInfo.toInt()
            variant4 = payload1.address.f0.toInt()
            variant5 = payload1.address.f1.toInt()
            variant6 = payload1.address.f2.toInt()
            variant7 = payload1.address.f3.toInt()
            variant8 = payload1.address.f4.toInt()
            variant9 = payload1.address.f5.toInt()
            variant10 = payload1.address.f6.toInt()
            variant11 = payload1.address.f7.toInt()
            variant12 = payload1.scopeId.toInt()
          }
          else -> error("unreachable")
        }
        // VariantLower END
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_startBind(
            handle,
            handle0,
            variant,
            variant2,
            variant3,
            variant4,
            variant5,
            variant6,
            variant7,
            variant8,
            variant9,
            variant10,
            variant11,
            variant12,
            ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun finishBind(): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_finishBind(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Set up inbound & outbound communication channels, optionally to a specific peer.
     *
     * This function only changes the local socket configuration and does not generate any network
     * traffic. On success, the `remote-address` of the socket is updated. The `local-address` may
     * be updated as well, based on the best network path to `remote-address`.
     *
     * When a `remote-address` is provided, the returned streams are limited to communicating with
     * that specific peer:
     * - `send` can only be used to send to this destination.
     * - `receive` will only return datagrams sent from the provided `remote-address`.
     *
     * This method may be called multiple times on the same socket to change its association, but
     * only the most recently returned pair of streams will be operational. Implementations may trap
     * if the streams returned by a previous invocation haven't been dropped yet before calling
     * `stream` again.
     *
     * The POSIX equivalent in pseudo-code is:
     * ```text
     * if (was previously connected) {
     * connect(s, AF_UNSPEC)
     * }
     * if (remote_address is Some) {
     * connect(s, remote_address)
     * }
     * ```
     *
     * Unlike in POSIX, the socket must already be explicitly bound.
     *
     * # Typical errors
     * - `invalid-argument`: The `remote-address` has the wrong address family. (EAFNOSUPPORT)
     * - `invalid-argument`: The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` /
     *   `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
     * - `invalid-argument`: The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
     * - `invalid-state`: The socket is not bound.
     * - `address-in-use`: Tried to perform an implicit bind, but there were no ephemeral ports
     *   available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
     * - `remote-unreachable`: The remote address is not reachable. (ECONNRESET, ENETRESET,
     *   EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
     * - `connection-refused`: The connection was refused. (ECONNREFUSED)
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
     * - <https://man7.org/linux/man-pages/man2/connect.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
     * - <https://man.freebsd.org/cgi/man.cgi?connect>
     */
    public fun stream(
        remoteAddress: Network.IpSocketAddress?
    ): Result<Pair<Udp.IncomingDatagramStream, Udp.OutgoingDatagramStream>> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val option: Int
        val option14: Int
        val option15: Int
        val option16: Int
        val option17: Int
        val option18: Int
        val option19: Int
        val option20: Int
        val option21: Int
        val option22: Int
        val option23: Int
        val option24: Int
        val option25: Int
        val payload0 = remoteAddress
        if (payload0 != null) {
          // VariantLower START
          val variant: Int
          val variant3: Int
          val variant4: Int
          val variant5: Int
          val variant6: Int
          val variant7: Int
          val variant8: Int
          val variant9: Int
          val variant10: Int
          val variant11: Int
          val variant12: Int
          val variant13: Int
          when (val x = payload0) {
            is Network.IpSocketAddress.Ipv4 -> {
              val payload1 = x.value
              variant = 0
              variant3 = payload1.port.toInt()
              variant4 = payload1.address.f0.toInt()
              variant5 = payload1.address.f1.toInt()
              variant6 = payload1.address.f2.toInt()
              variant7 = payload1.address.f3.toInt()
              variant8 = 0
              variant9 = 0
              variant10 = 0
              variant11 = 0
              variant12 = 0
              variant13 = 0
            }
            is Network.IpSocketAddress.Ipv6 -> {
              val payload2 = x.value
              variant = 1
              variant3 = payload2.port.toInt()
              variant4 = payload2.flowInfo.toInt()
              variant5 = payload2.address.f0.toInt()
              variant6 = payload2.address.f1.toInt()
              variant7 = payload2.address.f2.toInt()
              variant8 = payload2.address.f3.toInt()
              variant9 = payload2.address.f4.toInt()
              variant10 = payload2.address.f5.toInt()
              variant11 = payload2.address.f6.toInt()
              variant12 = payload2.address.f7.toInt()
              variant13 = payload2.scopeId.toInt()
            }
            else -> error("unreachable")
          }
          // VariantLower END
          option = 1
          option14 = variant
          option15 = variant3
          option16 = variant4
          option17 = variant5
          option18 = variant6
          option19 = variant7
          option20 = variant8
          option21 = variant9
          option22 = variant10
          option23 = variant11
          option24 = variant12
          option25 = variant13
        } else {
          option = 0
          option14 = 0
          option15 = 0
          option16 = 0
          option17 = 0
          option18 = 0
          option19 = 0
          option20 = 0
          option21 = 0
          option22 = 0
          option23 = 0
          option24 = 0
          option25 = 0
        }
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_stream(
            handle,
            option,
            option14,
            option15,
            option16,
            option17,
            option18,
            option19,
            option20,
            option21,
            option22,
            option23,
            option24,
            option25,
            ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              val resource = Udp.IncomingDatagramStream(ResourceHandle((ptr + 4).ptr.loadInt()))
              val resource27 = Udp.OutgoingDatagramStream(ResourceHandle((ptr + 8).ptr.loadInt()))

              Result<Pair<Udp.IncomingDatagramStream, Udp.OutgoingDatagramStream>>
                  .success(
                      Pair<Udp.IncomingDatagramStream, Udp.OutgoingDatagramStream>(
                          resource,
                          resource27,
                      ))
            } else {
              Result<Pair<Udp.IncomingDatagramStream, Udp.OutgoingDatagramStream>>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Get the current bound address.
     *
     * POSIX mentions:
     * > If the socket has not been bound to a local name, the value stored in the object pointed to
     * > by `address` is unspecified.
     *
     * WASI is stricter and requires `local-address` to return `invalid-state` when the socket
     * hasn't been bound yet.
     *
     * # Typical errors
     * - `invalid-state`: The socket is not bound to any local address.
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
     * - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
     * - <https://man.freebsd.org/cgi/man.cgi?getsockname>
     */
    public fun localAddress(): Result<Network.IpSocketAddress> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=36, align=4)*/ allocator.allocate(36).address.toInt()
        __wasm_import_localAddress(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      Network.IpSocketAddress.Ipv4(
                          Network.Ipv4SocketAddress(
                              (ptr + 8).ptr.loadUShort().toInt().toUShort(),
                              Tuple4<UByte, UByte, UByte, UByte>(
                                  (ptr + 10).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 11).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 12).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 13).ptr.loadUByte().toInt().toUByte(),
                              ),
                          ))
                    }
                    1 -> {
                      Network.IpSocketAddress.Ipv6(
                          Network.Ipv6SocketAddress(
                              (ptr + 8).ptr.loadUShort().toInt().toUShort(),
                              (ptr + 12).ptr.loadInt().toUInt(),
                              Tuple8<
                                  UShort, UShort, UShort, UShort, UShort, UShort, UShort, UShort>(
                                  (ptr + 16).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 18).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 20).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 22).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 24).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 26).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 28).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 30).ptr.loadUShort().toInt().toUShort(),
                              ),
                              (ptr + 32).ptr.loadInt().toUInt(),
                          ))
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<Network.IpSocketAddress>.success(variant)
            } else {
              Result<Network.IpSocketAddress>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Get the address the socket is currently streaming to.
     *
     * # Typical errors
     * - `invalid-state`: The socket is not streaming to a specific remote address. (ENOTCONN)
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
     * - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
     * - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
     */
    public fun remoteAddress(): Result<Network.IpSocketAddress> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=36, align=4)*/ allocator.allocate(36).address.toInt()
        __wasm_import_remoteAddress(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      Network.IpSocketAddress.Ipv4(
                          Network.Ipv4SocketAddress(
                              (ptr + 8).ptr.loadUShort().toInt().toUShort(),
                              Tuple4<UByte, UByte, UByte, UByte>(
                                  (ptr + 10).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 11).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 12).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 13).ptr.loadUByte().toInt().toUByte(),
                              ),
                          ))
                    }
                    1 -> {
                      Network.IpSocketAddress.Ipv6(
                          Network.Ipv6SocketAddress(
                              (ptr + 8).ptr.loadUShort().toInt().toUShort(),
                              (ptr + 12).ptr.loadInt().toUInt(),
                              Tuple8<
                                  UShort, UShort, UShort, UShort, UShort, UShort, UShort, UShort>(
                                  (ptr + 16).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 18).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 20).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 22).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 24).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 26).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 28).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 30).ptr.loadUShort().toInt().toUShort(),
                              ),
                              (ptr + 32).ptr.loadInt().toUInt(),
                          ))
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<Network.IpSocketAddress>.success(variant)
            } else {
              Result<Network.IpSocketAddress>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Whether this is a IPv4 or IPv6 socket.
     *
     * Equivalent to the SO_DOMAIN socket option.
     */
    public fun addressFamily(): Network.IpAddressFamily {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_addressFamily(handle)
        freeAllComponentModelReallocAllocatedMemory()
        return Network.IpAddressFamily.values()[ret]
      }
      // </editor-fold>
    }
    /**
     * Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
     *
     * If the provided value is 0, an `invalid-argument` error is returned.
     *
     * # Typical errors
     * - `invalid-argument`: (set) The TTL value must be 1 or higher.
     */
    public fun unicastHopLimit(): Result<UByte> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_unicastHopLimit(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<UByte>.success((ptr + 1).ptr.loadUByte().toInt().toUByte())
            } else {
              Result<UByte>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun setUnicastHopLimit(value: UByte): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setUnicastHopLimit(handle, value.toInt(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * The kernel buffer space reserved for sends/receives on this socket.
     *
     * If the provided value is 0, an `invalid-argument` error is returned. Any other value will
     * never cause an error, but it might be silently clamped and/or rounded. I.e. after setting a
     * value, reading the same setting back may return a different value.
     *
     * Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
     *
     * # Typical errors
     * - `invalid-argument`: (set) The provided value was 0.
     */
    public fun receiveBufferSize(): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_receiveBufferSize(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              Result<ULong>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun setReceiveBufferSize(value: ULong): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setReceiveBufferSize(handle, value.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun sendBufferSize(): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_sendBufferSize(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              Result<ULong>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun setSendBufferSize(value: ULong): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setSendBufferSize(handle, value.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Create a `pollable` which will resolve once the socket is ready for I/O.
     *
     * Note: this function is here for WASI Preview2 only. It's planned to be removed when `future`
     * is natively supported in Preview3.
     */
    public fun subscribe(): Poll.Pollable {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_subscribe5(handle)
        freeAllComponentModelReallocAllocatedMemory()
        val resource = Poll.Pollable(ResourceHandle(ret))
        return resource
      }
      // </editor-fold>
    }

    companion object {}
  }

  class IncomingDatagramStream : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Udp_IncomingDatagramStream_drop(__handle.value)
    }
    /**
     * Receive messages on the socket.
     *
     * This function attempts to receive up to `max-results` datagrams on the socket without
     * blocking. The returned list may contain fewer elements than requested, but never more.
     *
     * This function returns successfully with an empty list when either:
     * - `max-results` is 0, or:
     * - `max-results` is greater than 0, but no results are immediately available. This function
     *   never returns `error(would-block)`.
     *
     * # Typical errors
     * - `remote-unreachable`: The remote address is not reachable. (ECONNRESET, ENETRESET on
     *   Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
     * - `connection-refused`: The connection was refused. (ECONNREFUSED)
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
     * - <https://man7.org/linux/man-pages/man2/recv.2.html>
     * - <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
     * - <https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms741687(v=vs.85)>
     * - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
     */
    public fun receive(maxResults: ULong): Result<List<Udp.IncomingDatagram>> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_receive(handle, maxResults.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {

              val list0 = ArrayList<Udp.IncomingDatagram>((ptr + 8).ptr.loadInt())
              for (i1 in 0 until (ptr + 8).ptr.loadInt()) {
                val base = ((ptr + 4).ptr.loadInt()) + (i1 * 40)

                val list = ArrayList<UByte>((base + 4).ptr.loadInt())
                for (i in 0 until (base + 4).ptr.loadInt()) {
                  val base = ((base + 0).ptr.loadInt()) + (i * 1)

                  list.add((base + 0).ptr.loadUByte().toInt().toUByte())
                }
                // VariantLift START.
                val variant =
                    when ((base + 8).ptr.loadUByte().toInt()) {
                      0 -> {
                        Network.IpSocketAddress.Ipv4(
                            Network.Ipv4SocketAddress(
                                (base + 12).ptr.loadUShort().toInt().toUShort(),
                                Tuple4<UByte, UByte, UByte, UByte>(
                                    (base + 14).ptr.loadUByte().toInt().toUByte(),
                                    (base + 15).ptr.loadUByte().toInt().toUByte(),
                                    (base + 16).ptr.loadUByte().toInt().toUByte(),
                                    (base + 17).ptr.loadUByte().toInt().toUByte(),
                                ),
                            ))
                      }
                      1 -> {
                        Network.IpSocketAddress.Ipv6(
                            Network.Ipv6SocketAddress(
                                (base + 12).ptr.loadUShort().toInt().toUShort(),
                                (base + 16).ptr.loadInt().toUInt(),
                                Tuple8<
                                    UShort, UShort, UShort, UShort, UShort, UShort, UShort, UShort>(
                                    (base + 20).ptr.loadUShort().toInt().toUShort(),
                                    (base + 22).ptr.loadUShort().toInt().toUShort(),
                                    (base + 24).ptr.loadUShort().toInt().toUShort(),
                                    (base + 26).ptr.loadUShort().toInt().toUShort(),
                                    (base + 28).ptr.loadUShort().toInt().toUShort(),
                                    (base + 30).ptr.loadUShort().toInt().toUShort(),
                                    (base + 32).ptr.loadUShort().toInt().toUShort(),
                                    (base + 34).ptr.loadUShort().toInt().toUShort(),
                                ),
                                (base + 36).ptr.loadInt().toUInt(),
                            ))
                      }
                      else -> error("unreachable")
                    }
                // VariantLift END

                list0.add(
                    Udp.IncomingDatagram(
                        list,
                        variant,
                    ))
              }

              Result<List<Udp.IncomingDatagram>>.success(list0)
            } else {
              Result<List<Udp.IncomingDatagram>>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Create a `pollable` which will resolve once the stream is ready to receive again.
     *
     * Note: this function is here for WASI Preview2 only. It's planned to be removed when `future`
     * is natively supported in Preview3.
     */
    public fun subscribe(): Poll.Pollable {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_subscribe6(handle)
        freeAllComponentModelReallocAllocatedMemory()
        val resource = Poll.Pollable(ResourceHandle(ret))
        return resource
      }
      // </editor-fold>
    }

    companion object {}
  }

  class OutgoingDatagramStream : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Udp_OutgoingDatagramStream_drop(__handle.value)
    }
    /**
     * Check readiness for sending. This function never blocks.
     *
     * Returns the number of datagrams permitted for the next call to `send`, or an error. Calling
     * `send` with more datagrams than this function has permitted will trap.
     *
     * When this function returns ok(0), the `subscribe` pollable will become ready when this
     * function will report at least ok(1), or an error.
     *
     * Never returns `would-block`.
     */
    public fun checkSend(): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_checkSend(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              Result<ULong>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Send messages on the socket.
     *
     * This function attempts to send all provided `datagrams` on the socket without blocking and
     * returns how many messages were actually sent (or queued for sending). This function never
     * returns `error(would-block)`. If none of the datagrams were able to be sent, `ok(0)` is
     * returned.
     *
     * This function semantically behaves the same as iterating the `datagrams` list and
     * sequentially sending each individual datagram until either the end of the list has been
     * reached or the first error occurred. If at least one datagram has been sent successfully,
     * this function never returns an error.
     *
     * If the input list is empty, the function returns `ok(0)`.
     *
     * Each call to `send` must be permitted by a preceding `check-send`. Implementations must trap
     * if either `check-send` was not called or `datagrams` contains more items than `check-send`
     * permitted.
     *
     * # Typical errors
     * - `invalid-argument`: The `remote-address` has the wrong address family. (EAFNOSUPPORT)
     * - `invalid-argument`: The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` /
     *   `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
     * - `invalid-argument`: The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
     * - `invalid-argument`: The socket is in "connected" mode and `remote-address` is `some` value
     *   that does not match the address passed to `stream`. (EISCONN)
     * - `invalid-argument`: The socket is not "connected" and no value for `remote-address` was
     *   provided. (EDESTADDRREQ)
     * - `remote-unreachable`: The remote address is not reachable. (ECONNRESET, ENETRESET on
     *   Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
     * - `connection-refused`: The connection was refused. (ECONNREFUSED)
     * - `datagram-too-large`: The datagram is too large. (EMSGSIZE)
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
     * - <https://man7.org/linux/man-pages/man2/send.2.html>
     * - <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
     * - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
     */
    public fun send(datagrams: List<Udp.OutgoingDatagram>): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value

        val address3 = allocator.allocate(datagrams.size * 44 /*, align=4*/).address.toInt()
        for ((index4, el) in datagrams.withIndex()) {
          val base = address3 + (index4 * 44)

          val address = allocator.allocate(el.data.size * 1 /*, align=1*/).address.toInt()
          for ((index, el) in el.data.withIndex()) {
            val base = address + (index * 1)
            (base + 0).ptr.storeByte(el.toInt().toByte())
          }
          (base + 4).ptr.storeInt(el.data.size)
          (base + 0).ptr.storeInt(address)
          val payload0 = el.remoteAddress
          if (payload0 != null) {
            (base + 8).ptr.storeByte(1.toByte())
            // VariantLower START
            when (val x = payload0) {
              is Network.IpSocketAddress.Ipv4 -> {
                val payload1 = x.value
                (base + 12).ptr.storeByte(0.toByte())
                (base + 16).ptr.storeShort(payload1.port.toInt().toShort())
                (base + 18).ptr.storeByte(payload1.address.f0.toInt().toByte())
                (base + 19).ptr.storeByte(payload1.address.f1.toInt().toByte())
                (base + 20).ptr.storeByte(payload1.address.f2.toInt().toByte())
                (base + 21).ptr.storeByte(payload1.address.f3.toInt().toByte())
              }
              is Network.IpSocketAddress.Ipv6 -> {
                val payload2 = x.value
                (base + 12).ptr.storeByte(1.toByte())
                (base + 16).ptr.storeShort(payload2.port.toInt().toShort())
                (base + 20).ptr.storeInt(payload2.flowInfo.toInt())
                (base + 24).ptr.storeShort(payload2.address.f0.toInt().toShort())
                (base + 26).ptr.storeShort(payload2.address.f1.toInt().toShort())
                (base + 28).ptr.storeShort(payload2.address.f2.toInt().toShort())
                (base + 30).ptr.storeShort(payload2.address.f3.toInt().toShort())
                (base + 32).ptr.storeShort(payload2.address.f4.toInt().toShort())
                (base + 34).ptr.storeShort(payload2.address.f5.toInt().toShort())
                (base + 36).ptr.storeShort(payload2.address.f6.toInt().toShort())
                (base + 38).ptr.storeShort(payload2.address.f7.toInt().toShort())
                (base + 40).ptr.storeInt(payload2.scopeId.toInt())
              }
              else -> error("unreachable")
            }
            // VariantLower END
          } else {
            (base + 8).ptr.storeByte(0.toByte())
          }
        }
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_send(handle, address3, datagrams.size, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              Result<ULong>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Create a `pollable` which will resolve once the stream is ready to send again.
     *
     * Note: this function is here for WASI Preview2 only. It's planned to be removed when `future`
     * is natively supported in Preview3.
     */
    public fun subscribe(): Poll.Pollable {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_subscribe7(handle)
        freeAllComponentModelReallocAllocatedMemory()
        val resource = Poll.Pollable(ResourceHandle(ret))
        return resource
      }
      // </editor-fold>
    }

    companion object {}
  }
}

object UdpCreateSocket {
  /**
   * Create a new UDP socket.
   *
   * Similar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX. On IPv6 sockets,
   * IPV6_V6ONLY is enabled by default and can't be configured otherwise.
   *
   * This function does not require a network capability handle. This is considered to be safe
   * because at time of creation, the socket is not bound to any `network` yet. Up to the moment
   * `bind` is called, the socket is effectively an in-memory configuration object, unable to
   * communicate with the outside world.
   *
   * All sockets are non-blocking. Use the wasi-poll interface to block on asynchronous operations.
   *
   * # Typical errors
   * - `not-supported`: The specified `address-family` is not supported. (EAFNOSUPPORT)
   * - `new-socket-limit`: The new socket resource could not be created because of a system limit.
   *   (EMFILE, ENFILE)
   *
   * # References:
   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
   * - <https://man7.org/linux/man-pages/man2/socket.2.html>
   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
   * - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
   */
  public fun createUdpSocket(addressFamily: Network.IpAddressFamily): Result<Udp.UdpSocket> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_createUdpSocket(addressFamily.ordinal, ptr)
      freeAllComponentModelReallocAllocatedMemory()
      val result =
          if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
            val resource = Udp.UdpSocket(ResourceHandle((ptr + 4).ptr.loadInt()))

            Result<Udp.UdpSocket>.success(resource)
          } else {
            Result<Udp.UdpSocket>
                .failure(
                    ComponentException(
                        Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
          }
      return result
    }
    // </editor-fold>
  }
}

object Tcp {

  enum class ShutdownType {
    /** Similar to `SHUT_RD` in POSIX. */
    RECEIVE,
    /** Similar to `SHUT_WR` in POSIX. */
    SEND,
    /** Similar to `SHUT_RDWR` in POSIX. */
    BOTH,
  }
  /**
   * A TCP socket resource.
   *
   * The socket can be in one of the following states:
   * - `unbound`
   * - `bind-in-progress`
   * - `bound` (See note below)
   * - `listen-in-progress`
   * - `listening`
   * - `connect-in-progress`
   * - `connected`
   * - `closed` See <https://github.com/WebAssembly/wasi-sockets/TcpSocketOperationalSemantics.md>
   *   for a more information.
   *
   * Note: Except where explicitly mentioned, whenever this documentation uses the term "bound"
   * without backticks it actually means: in the `bound` state *or higher*. (i.e. `bound`,
   * `listen-in-progress`, `listening`, `connect-in-progress` or `connected`)
   *
   * In addition to the general error codes documented on the `network::error-code` type, TCP socket
   * methods may always return `error(invalid-state)` when in the `closed` state.
   */
  class TcpSocket : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_Tcp_TcpSocket_drop(__handle.value)
    }
    /**
     * Bind the socket to a specific network on the provided IP address and port.
     *
     * If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation
     * to decide which network interface(s) to bind to. If the TCP/UDP port is zero, the socket will
     * be bound to a random free port.
     *
     * Bind can be attempted multiple times on the same socket, even with different arguments on
     * each iteration. But never concurrently and only as long as the previous bind failed. Once a
     * bind succeeds, the binding can't be changed anymore.
     *
     * # Typical errors
     * - `invalid-argument`: The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT
     *   on Windows)
     * - `invalid-argument`: `local-address` is not a unicast address. (EINVAL)
     * - `invalid-argument`: `local-address` is an IPv4-mapped IPv6 address. (EINVAL)
     * - `invalid-state`: The socket is already bound. (EINVAL)
     * - `address-in-use`: No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
     * - `address-in-use`: Address is already in use. (EADDRINUSE)
     * - `address-not-bindable`: `local-address` is not an address that the `network` can bind to.
     *   (EADDRNOTAVAIL)
     * - `not-in-progress`: A `bind` operation is not in progress.
     * - `would-block`: Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
     *
     * # Implementors note
     * When binding to a non-zero port, this bind operation shouldn't be affected by the TIME_WAIT
     * state of a recently closed socket on the same local address. In practice this means that the
     * SO_REUSEADDR socket option should be set implicitly on all platforms, except on Windows where
     * this is the default behavior and SO_REUSEADDR performs something different entirely.
     *
     * Unlike in POSIX, in WASI the bind operation is async. This enables interactive WASI hosts to
     * inject permission prompts. Runtimes that don't want to make use of this ability can simply
     * call the native `bind` as part of either `start-bind` or `finish-bind`.
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
     * - <https://man7.org/linux/man-pages/man2/bind.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
     * - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
     */
    public fun startBind(
        network: Network.Network,
        localAddress: Network.IpSocketAddress
    ): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        var handle0 = network.__handle.value
        // VariantLower START
        val variant: Int
        val variant2: Int
        val variant3: Int
        val variant4: Int
        val variant5: Int
        val variant6: Int
        val variant7: Int
        val variant8: Int
        val variant9: Int
        val variant10: Int
        val variant11: Int
        val variant12: Int
        when (val x = localAddress) {
          is Network.IpSocketAddress.Ipv4 -> {
            val payload = x.value
            variant = 0
            variant2 = payload.port.toInt()
            variant3 = payload.address.f0.toInt()
            variant4 = payload.address.f1.toInt()
            variant5 = payload.address.f2.toInt()
            variant6 = payload.address.f3.toInt()
            variant7 = 0
            variant8 = 0
            variant9 = 0
            variant10 = 0
            variant11 = 0
            variant12 = 0
          }
          is Network.IpSocketAddress.Ipv6 -> {
            val payload1 = x.value
            variant = 1
            variant2 = payload1.port.toInt()
            variant3 = payload1.flowInfo.toInt()
            variant4 = payload1.address.f0.toInt()
            variant5 = payload1.address.f1.toInt()
            variant6 = payload1.address.f2.toInt()
            variant7 = payload1.address.f3.toInt()
            variant8 = payload1.address.f4.toInt()
            variant9 = payload1.address.f5.toInt()
            variant10 = payload1.address.f6.toInt()
            variant11 = payload1.address.f7.toInt()
            variant12 = payload1.scopeId.toInt()
          }
          else -> error("unreachable")
        }
        // VariantLower END
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_startBind8(
            handle,
            handle0,
            variant,
            variant2,
            variant3,
            variant4,
            variant5,
            variant6,
            variant7,
            variant8,
            variant9,
            variant10,
            variant11,
            variant12,
            ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun finishBind(): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_finishBind9(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Connect to a remote endpoint.
     *
     * On success:
     * - the socket is transitioned into the `connection` state.
     * - a pair of streams is returned that can be used to read & write to the connection
     *
     * After a failed connection attempt, the socket will be in the `closed` state and the only
     * valid action left is to `drop` the socket. A single socket can not be used to connect more
     * than once.
     *
     * # Typical errors
     * - `invalid-argument`: The `remote-address` has the wrong address family. (EAFNOSUPPORT)
     * - `invalid-argument`: `remote-address` is not a unicast address. (EINVAL, ENETUNREACH on
     *   Linux, EAFNOSUPPORT on MacOS)
     * - `invalid-argument`: `remote-address` is an IPv4-mapped IPv6 address. (EINVAL, EADDRNOTAVAIL
     *   on Illumos)
     * - `invalid-argument`: The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` /
     *   `::`). (EADDRNOTAVAIL on Windows)
     * - `invalid-argument`: The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)
     * - `invalid-argument`: The socket is already attached to a different network. The `network`
     *   passed to `connect` must be identical to the one passed to `bind`.
     * - `invalid-state`: The socket is already in the `connected` state. (EISCONN)
     * - `invalid-state`: The socket is already in the `listening` state. (EOPNOTSUPP, EINVAL on
     *   Windows)
     * - `timeout`: Connection timed out. (ETIMEDOUT)
     * - `connection-refused`: The connection was forcefully rejected. (ECONNREFUSED)
     * - `connection-reset`: The connection was reset. (ECONNRESET)
     * - `connection-aborted`: The connection was aborted. (ECONNABORTED)
     * - `remote-unreachable`: The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN,
     *   ENETUNREACH, ENETDOWN, ENONET)
     * - `address-in-use`: Tried to perform an implicit bind, but there were no ephemeral ports
     *   available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
     * - `not-in-progress`: A connect operation is not in progress.
     * - `would-block`: Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
     *
     * # Implementors note
     * The POSIX equivalent of `start-connect` is the regular `connect` syscall. Because all WASI
     * sockets are non-blocking this is expected to return EINPROGRESS, which should be translated
     * to `ok()` in WASI.
     *
     * The POSIX equivalent of `finish-connect` is a `poll` for event `POLLOUT` with a timeout of 0
     * on the socket descriptor. Followed by a check for the `SO_ERROR` socket option, in case the
     * poll signaled readiness.
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
     * - <https://man7.org/linux/man-pages/man2/connect.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
     * - <https://man.freebsd.org/cgi/man.cgi?connect>
     */
    public fun startConnect(
        network: Network.Network,
        remoteAddress: Network.IpSocketAddress
    ): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        var handle0 = network.__handle.value
        // VariantLower START
        val variant: Int
        val variant2: Int
        val variant3: Int
        val variant4: Int
        val variant5: Int
        val variant6: Int
        val variant7: Int
        val variant8: Int
        val variant9: Int
        val variant10: Int
        val variant11: Int
        val variant12: Int
        when (val x = remoteAddress) {
          is Network.IpSocketAddress.Ipv4 -> {
            val payload = x.value
            variant = 0
            variant2 = payload.port.toInt()
            variant3 = payload.address.f0.toInt()
            variant4 = payload.address.f1.toInt()
            variant5 = payload.address.f2.toInt()
            variant6 = payload.address.f3.toInt()
            variant7 = 0
            variant8 = 0
            variant9 = 0
            variant10 = 0
            variant11 = 0
            variant12 = 0
          }
          is Network.IpSocketAddress.Ipv6 -> {
            val payload1 = x.value
            variant = 1
            variant2 = payload1.port.toInt()
            variant3 = payload1.flowInfo.toInt()
            variant4 = payload1.address.f0.toInt()
            variant5 = payload1.address.f1.toInt()
            variant6 = payload1.address.f2.toInt()
            variant7 = payload1.address.f3.toInt()
            variant8 = payload1.address.f4.toInt()
            variant9 = payload1.address.f5.toInt()
            variant10 = payload1.address.f6.toInt()
            variant11 = payload1.address.f7.toInt()
            variant12 = payload1.scopeId.toInt()
          }
          else -> error("unreachable")
        }
        // VariantLower END
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_startConnect(
            handle,
            handle0,
            variant,
            variant2,
            variant3,
            variant4,
            variant5,
            variant6,
            variant7,
            variant8,
            variant9,
            variant10,
            variant11,
            variant12,
            ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun finishConnect(): Result<Pair<Streams.InputStream, Streams.OutputStream>> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=12, align=4)*/ allocator.allocate(12).address.toInt()
        __wasm_import_finishConnect(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              val resource = Streams.InputStream(ResourceHandle((ptr + 4).ptr.loadInt()))
              val resource0 = Streams.OutputStream(ResourceHandle((ptr + 8).ptr.loadInt()))

              Result<Pair<Streams.InputStream, Streams.OutputStream>>
                  .success(
                      Pair<Streams.InputStream, Streams.OutputStream>(
                          resource,
                          resource0,
                      ))
            } else {
              Result<Pair<Streams.InputStream, Streams.OutputStream>>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Start listening for new connections.
     *
     * Transitions the socket into the `listening` state.
     *
     * Unlike POSIX, the socket must already be explicitly bound.
     *
     * # Typical errors
     * - `invalid-state`: The socket is not bound to any local address. (EDESTADDRREQ)
     * - `invalid-state`: The socket is already in the `connected` state. (EISCONN, EINVAL on BSD)
     * - `invalid-state`: The socket is already in the `listening` state.
     * - `address-in-use`: Tried to perform an implicit bind, but there were no ephemeral ports
     *   available. (EADDRINUSE)
     * - `not-in-progress`: A listen operation is not in progress.
     * - `would-block`: Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
     *
     * # Implementors note
     * Unlike in POSIX, in WASI the listen operation is async. This enables interactive WASI hosts
     * to inject permission prompts. Runtimes that don't want to make use of this ability can simply
     * call the native `listen` as part of either `start-listen` or `finish-listen`.
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
     * - <https://man7.org/linux/man-pages/man2/listen.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
     * - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
     */
    public fun startListen(): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_startListen(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun finishListen(): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_finishListen(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Accept a new client socket.
     *
     * The returned socket is bound and in the `connected` state. The following properties are
     * inherited from the listener socket:
     * - `address-family`
     * - `keep-alive-enabled`
     * - `keep-alive-idle-time`
     * - `keep-alive-interval`
     * - `keep-alive-count`
     * - `hop-limit`
     * - `receive-buffer-size`
     * - `send-buffer-size`
     *
     * On success, this function returns the newly accepted client socket along with a pair of
     * streams that can be used to read & write to the connection.
     *
     * # Typical errors
     * - `invalid-state`: Socket is not in the `listening` state. (EINVAL)
     * - `would-block`: No pending connections at the moment. (EWOULDBLOCK, EAGAIN)
     * - `connection-aborted`: An incoming connection was pending, but was terminated by the client
     *   before this listener could accept it. (ECONNABORTED)
     * - `new-socket-limit`: The new socket resource could not be created because of a system limit.
     *   (EMFILE, ENFILE)
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
     * - <https://man7.org/linux/man-pages/man2/accept.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
     * - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
     */
    public fun accept(): Result<Triple<Tcp.TcpSocket, Streams.InputStream, Streams.OutputStream>> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=4)*/ allocator.allocate(16).address.toInt()
        __wasm_import_accept(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              val resource = Tcp.TcpSocket(ResourceHandle((ptr + 4).ptr.loadInt()))
              val resource0 = Streams.InputStream(ResourceHandle((ptr + 8).ptr.loadInt()))
              val resource1 = Streams.OutputStream(ResourceHandle((ptr + 12).ptr.loadInt()))

              Result<Triple<Tcp.TcpSocket, Streams.InputStream, Streams.OutputStream>>
                  .success(
                      Triple<Tcp.TcpSocket, Streams.InputStream, Streams.OutputStream>(
                          resource,
                          resource0,
                          resource1,
                      ))
            } else {
              Result<Triple<Tcp.TcpSocket, Streams.InputStream, Streams.OutputStream>>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Get the bound local address.
     *
     * POSIX mentions:
     * > If the socket has not been bound to a local name, the value stored in the object pointed to
     * > by `address` is unspecified.
     *
     * WASI is stricter and requires `local-address` to return `invalid-state` when the socket
     * hasn't been bound yet.
     *
     * # Typical errors
     * - `invalid-state`: The socket is not bound to any local address.
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
     * - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
     * - <https://man.freebsd.org/cgi/man.cgi?getsockname>
     */
    public fun localAddress(): Result<Network.IpSocketAddress> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=36, align=4)*/ allocator.allocate(36).address.toInt()
        __wasm_import_localAddress10(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      Network.IpSocketAddress.Ipv4(
                          Network.Ipv4SocketAddress(
                              (ptr + 8).ptr.loadUShort().toInt().toUShort(),
                              Tuple4<UByte, UByte, UByte, UByte>(
                                  (ptr + 10).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 11).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 12).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 13).ptr.loadUByte().toInt().toUByte(),
                              ),
                          ))
                    }
                    1 -> {
                      Network.IpSocketAddress.Ipv6(
                          Network.Ipv6SocketAddress(
                              (ptr + 8).ptr.loadUShort().toInt().toUShort(),
                              (ptr + 12).ptr.loadInt().toUInt(),
                              Tuple8<
                                  UShort, UShort, UShort, UShort, UShort, UShort, UShort, UShort>(
                                  (ptr + 16).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 18).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 20).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 22).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 24).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 26).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 28).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 30).ptr.loadUShort().toInt().toUShort(),
                              ),
                              (ptr + 32).ptr.loadInt().toUInt(),
                          ))
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<Network.IpSocketAddress>.success(variant)
            } else {
              Result<Network.IpSocketAddress>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Get the remote address.
     *
     * # Typical errors
     * - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
     * - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
     * - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
     */
    public fun remoteAddress(): Result<Network.IpSocketAddress> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=36, align=4)*/ allocator.allocate(36).address.toInt()
        __wasm_import_remoteAddress11(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              // VariantLift START.
              val variant =
                  when ((ptr + 4).ptr.loadUByte().toInt()) {
                    0 -> {
                      Network.IpSocketAddress.Ipv4(
                          Network.Ipv4SocketAddress(
                              (ptr + 8).ptr.loadUShort().toInt().toUShort(),
                              Tuple4<UByte, UByte, UByte, UByte>(
                                  (ptr + 10).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 11).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 12).ptr.loadUByte().toInt().toUByte(),
                                  (ptr + 13).ptr.loadUByte().toInt().toUByte(),
                              ),
                          ))
                    }
                    1 -> {
                      Network.IpSocketAddress.Ipv6(
                          Network.Ipv6SocketAddress(
                              (ptr + 8).ptr.loadUShort().toInt().toUShort(),
                              (ptr + 12).ptr.loadInt().toUInt(),
                              Tuple8<
                                  UShort, UShort, UShort, UShort, UShort, UShort, UShort, UShort>(
                                  (ptr + 16).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 18).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 20).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 22).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 24).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 26).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 28).ptr.loadUShort().toInt().toUShort(),
                                  (ptr + 30).ptr.loadUShort().toInt().toUShort(),
                              ),
                              (ptr + 32).ptr.loadInt().toUInt(),
                          ))
                    }
                    else -> error("unreachable")
                  }
              // VariantLift END

              Result<Network.IpSocketAddress>.success(variant)
            } else {
              Result<Network.IpSocketAddress>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Whether the socket is in the `listening` state.
     *
     * Equivalent to the SO_ACCEPTCONN socket option.
     */
    public fun isListening(): Boolean {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_isListening(handle)
        freeAllComponentModelReallocAllocatedMemory()
        return (ret != 0)
      }
      // </editor-fold>
    }
    /**
     * Whether this is a IPv4 or IPv6 socket.
     *
     * Equivalent to the SO_DOMAIN socket option.
     */
    public fun addressFamily(): Network.IpAddressFamily {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_addressFamily12(handle)
        freeAllComponentModelReallocAllocatedMemory()
        return Network.IpAddressFamily.values()[ret]
      }
      // </editor-fold>
    }
    /**
     * Hints the desired listen queue size. Implementations are free to ignore this.
     *
     * If the provided value is 0, an `invalid-argument` error is returned. Any other value will
     * never cause an error, but it might be silently clamped and/or rounded.
     *
     * # Typical errors
     * - `not-supported`: (set) The platform does not support changing the backlog size after the
     *   initial listen.
     * - `invalid-argument`: (set) The provided value was 0.
     * - `invalid-state`: (set) The socket is in the `connect-in-progress` or `connected` state.
     */
    public fun setListenBacklogSize(value: ULong): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setListenBacklogSize(handle, value.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Enables or disables keepalive.
     *
     * The keepalive behavior can be adjusted using:
     * - `keep-alive-idle-time`
     * - `keep-alive-interval`
     * - `keep-alive-count` These properties can be configured while `keep-alive-enabled` is false,
     *   but only come into effect when `keep-alive-enabled` is true.
     *
     * Equivalent to the SO_KEEPALIVE socket option.
     */
    public fun keepAliveEnabled(): Result<Boolean> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_keepAliveEnabled(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Boolean>.success(((ptr + 1).ptr.loadUByte().toInt() != 0))
            } else {
              Result<Boolean>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun setKeepAliveEnabled(value: Boolean): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setKeepAliveEnabled(handle, (if (value) 1 else 0), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Amount of time the connection has to be idle before TCP starts sending keepalive packets.
     *
     * If the provided value is 0, an `invalid-argument` error is returned. Any other value will
     * never cause an error, but it might be silently clamped and/or rounded. I.e. after setting a
     * value, reading the same setting back may return a different value.
     *
     * Equivalent to the TCP_KEEPIDLE socket option. (TCP_KEEPALIVE on MacOS)
     *
     * # Typical errors
     * - `invalid-argument`: (set) The provided value was 0.
     */
    public fun keepAliveIdleTime(): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_keepAliveIdleTime(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              Result<ULong>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun setKeepAliveIdleTime(value: ULong): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setKeepAliveIdleTime(handle, value.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * The time between keepalive packets.
     *
     * If the provided value is 0, an `invalid-argument` error is returned. Any other value will
     * never cause an error, but it might be silently clamped and/or rounded. I.e. after setting a
     * value, reading the same setting back may return a different value.
     *
     * Equivalent to the TCP_KEEPINTVL socket option.
     *
     * # Typical errors
     * - `invalid-argument`: (set) The provided value was 0.
     */
    public fun keepAliveInterval(): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_keepAliveInterval(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              Result<ULong>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun setKeepAliveInterval(value: ULong): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setKeepAliveInterval(handle, value.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * The maximum amount of keepalive packets TCP should send before aborting the connection.
     *
     * If the provided value is 0, an `invalid-argument` error is returned. Any other value will
     * never cause an error, but it might be silently clamped and/or rounded. I.e. after setting a
     * value, reading the same setting back may return a different value.
     *
     * Equivalent to the TCP_KEEPCNT socket option.
     *
     * # Typical errors
     * - `invalid-argument`: (set) The provided value was 0.
     */
    public fun keepAliveCount(): Result<UInt> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
        __wasm_import_keepAliveCount(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<UInt>.success((ptr + 4).ptr.loadInt().toUInt())
            } else {
              Result<UInt>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun setKeepAliveCount(value: UInt): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setKeepAliveCount(handle, value.toInt(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
     *
     * If the provided value is 0, an `invalid-argument` error is returned.
     *
     * # Typical errors
     * - `invalid-argument`: (set) The TTL value must be 1 or higher.
     */
    public fun hopLimit(): Result<UByte> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_hopLimit(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<UByte>.success((ptr + 1).ptr.loadUByte().toInt().toUByte())
            } else {
              Result<UByte>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun setHopLimit(value: UByte): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setHopLimit(handle, value.toInt(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * The kernel buffer space reserved for sends/receives on this socket.
     *
     * If the provided value is 0, an `invalid-argument` error is returned. Any other value will
     * never cause an error, but it might be silently clamped and/or rounded. I.e. after setting a
     * value, reading the same setting back may return a different value.
     *
     * Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
     *
     * # Typical errors
     * - `invalid-argument`: (set) The provided value was 0.
     */
    public fun receiveBufferSize(): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_receiveBufferSize13(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              Result<ULong>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun setReceiveBufferSize(value: ULong): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setReceiveBufferSize14(handle, value.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun sendBufferSize(): Result<ULong> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
        __wasm_import_sendBufferSize15(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<ULong>.success((ptr + 8).ptr.loadLong().toULong())
            } else {
              Result<ULong>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 8).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    public fun setSendBufferSize(value: ULong): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_setSendBufferSize16(handle, value.toLong(), ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Create a `pollable` which can be used to poll for, or block on, completion of any of the
     * asynchronous operations of this socket.
     *
     * When `finish-bind`, `finish-listen`, `finish-connect` or `accept` return
     * `error(would-block)`, this pollable can be used to wait for their success or failure, after
     * which the method can be retried.
     *
     * The pollable is not limited to the async operation that happens to be in progress at the time
     * of calling `subscribe` (if any). Theoretically, `subscribe` only has to be called once per
     * socket and can then be (re)used for the remainder of the socket's lifetime.
     *
     * See
     * <https://github.com/WebAssembly/wasi-sockets/TcpSocketOperationalSemantics.md#Pollable-readiness>
     * for a more information.
     *
     * Note: this function is here for WASI Preview2 only. It's planned to be removed when `future`
     * is natively supported in Preview3.
     */
    public fun subscribe(): Poll.Pollable {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_subscribe17(handle)
        freeAllComponentModelReallocAllocatedMemory()
        val resource = Poll.Pollable(ResourceHandle(ret))
        return resource
      }
      // </editor-fold>
    }
    /**
     * Initiate a graceful shutdown.
     * - `receive`: The socket is not expecting to receive any data from the peer. The
     *   `input-stream` associated with this socket will be closed. Any data still in the receive
     *   queue at time of calling this method will be discarded.
     * - `send`: The socket has no more data to send to the peer. The `output-stream` associated
     *   with this socket will be closed and a FIN packet will be sent.
     * - `both`: Same effect as `receive` & `send` combined.
     *
     * This function is idempotent. Shutting a down a direction more than once has no effect and
     * returns `ok`.
     *
     * The shutdown function does not close (drop) the socket.
     *
     * # Typical errors
     * - `invalid-state`: The socket is not in the `connected` state. (ENOTCONN)
     *
     * # References
     * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html>
     * - <https://man7.org/linux/man-pages/man2/shutdown.2.html>
     * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-shutdown>
     * - <https://man.freebsd.org/cgi/man.cgi?query=shutdown&sektion=2>
     */
    public fun shutdown(shutdownType: Tcp.ShutdownType): Result<Unit> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=2, align=1)*/ allocator.allocate(2).address.toInt()
        __wasm_import_shutdown(handle, shutdownType.ordinal, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              Result<Unit>.success(Unit)
            } else {
              Result<Unit>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 1).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }

    companion object {}
  }
}

object TcpCreateSocket {
  /**
   * Create a new TCP socket.
   *
   * Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX. On IPv6 sockets,
   * IPV6_V6ONLY is enabled by default and can't be configured otherwise.
   *
   * This function does not require a network capability handle. This is considered to be safe
   * because at time of creation, the socket is not bound to any `network` yet. Up to the moment
   * `bind`/`connect` is called, the socket is effectively an in-memory configuration object, unable
   * to communicate with the outside world.
   *
   * All sockets are non-blocking. Use the wasi-poll interface to block on asynchronous operations.
   *
   * # Typical errors
   * - `not-supported`: The specified `address-family` is not supported. (EAFNOSUPPORT)
   * - `new-socket-limit`: The new socket resource could not be created because of a system limit.
   *   (EMFILE, ENFILE)
   *
   * # References
   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
   * - <https://man7.org/linux/man-pages/man2/socket.2.html>
   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
   * - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
   */
  public fun createTcpSocket(addressFamily: Network.IpAddressFamily): Result<Tcp.TcpSocket> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_createTcpSocket(addressFamily.ordinal, ptr)
      freeAllComponentModelReallocAllocatedMemory()
      val result =
          if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
            val resource = Tcp.TcpSocket(ResourceHandle((ptr + 4).ptr.loadInt()))

            Result<Tcp.TcpSocket>.success(resource)
          } else {
            Result<Tcp.TcpSocket>
                .failure(
                    ComponentException(
                        Network.ErrorCode.values()[(ptr + 4).ptr.loadUByte().toInt()]))
          }
      return result
    }
    // </editor-fold>
  }
}

object IpNameLookup {
  class ResolveAddressStream : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    internal constructor(handle: ResourceHandle) {
      __handle = handle
    }

    override fun close() {
      __cm_resource_abi_import_IpNameLookup_ResolveAddressStream_drop(__handle.value)
    }
    /**
     * Returns the next address from the resolver.
     *
     * This function should be called multiple times. On each call, it will return the next address
     * in connection order preference. If all addresses have been exhausted, this function returns
     * `none`.
     *
     * This function never returns IPv4-mapped IPv6 addresses.
     *
     * # Typical errors
     * - `name-unresolvable`: Name does not exist or has no suitable associated IP addresses.
     *   (EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY)
     * - `temporary-resolver-failure`: A temporary failure in name resolution occurred. (EAI_AGAIN)
     * - `permanent-resolver-failure`: A permanent failure in name resolution occurred. (EAI_FAIL)
     * - `would-block`: A result is not available yet. (EWOULDBLOCK, EAGAIN)
     */
    public fun resolveNextAddress(): Result<Network.IpAddress?> {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ptr = /* RETURN_ADDRESS_ALLOC(size=22, align=2)*/ allocator.allocate(22).address.toInt()
        __wasm_import_resolveNextAddress(handle, ptr)
        freeAllComponentModelReallocAllocatedMemory()
        val result =
            if ((ptr + 0).ptr.loadUByte().toInt() == 0) {
              // OptionLift start
              val option =
                  if ((ptr + 2).ptr.loadUByte().toInt() == 1) {
                    // VariantLift START.
                    val variant =
                        when ((ptr + 4).ptr.loadUByte().toInt()) {
                          0 -> {
                            Network.IpAddress.Ipv4(
                                Tuple4<UByte, UByte, UByte, UByte>(
                                    (ptr + 6).ptr.loadUByte().toInt().toUByte(),
                                    (ptr + 7).ptr.loadUByte().toInt().toUByte(),
                                    (ptr + 8).ptr.loadUByte().toInt().toUByte(),
                                    (ptr + 9).ptr.loadUByte().toInt().toUByte(),
                                ))
                          }
                          1 -> {
                            Network.IpAddress.Ipv6(
                                Tuple8<
                                    UShort, UShort, UShort, UShort, UShort, UShort, UShort, UShort>(
                                    (ptr + 6).ptr.loadUShort().toInt().toUShort(),
                                    (ptr + 8).ptr.loadUShort().toInt().toUShort(),
                                    (ptr + 10).ptr.loadUShort().toInt().toUShort(),
                                    (ptr + 12).ptr.loadUShort().toInt().toUShort(),
                                    (ptr + 14).ptr.loadUShort().toInt().toUShort(),
                                    (ptr + 16).ptr.loadUShort().toInt().toUShort(),
                                    (ptr + 18).ptr.loadUShort().toInt().toUShort(),
                                    (ptr + 20).ptr.loadUShort().toInt().toUShort(),
                                ))
                          }
                          else -> error("unreachable")
                        }
                    // VariantLift END
                    variant
                  } else {
                    null
                  }
              // OptionLift end

              Result<Network.IpAddress?>.success(option)
            } else {
              Result<Network.IpAddress?>
                  .failure(
                      ComponentException(
                          Network.ErrorCode.values()[(ptr + 2).ptr.loadUByte().toInt()]))
            }
        return result
      }
      // </editor-fold>
    }
    /**
     * Create a `pollable` which will resolve once the stream is ready for I/O.
     *
     * Note: this function is here for WASI Preview2 only. It's planned to be removed when `future`
     * is natively supported in Preview3.
     */
    public fun subscribe(): Poll.Pollable {
      // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
      withScopedMemoryAllocator { allocator ->
        var handle = this.__handle.value
        val ret: Int = __wasm_import_subscribe18(handle)
        freeAllComponentModelReallocAllocatedMemory()
        val resource = Poll.Pollable(ResourceHandle(ret))
        return resource
      }
      // </editor-fold>
    }

    companion object {}
  }
  /**
   * Resolve an internet host name to a list of IP addresses.
   *
   * Unicode domain names are automatically converted to ASCII using IDNA encoding. If the input is
   * an IP address string, the address is parsed and returned as-is without making any external
   * requests.
   *
   * See the wasi-socket proposal README.md for a comparison with getaddrinfo.
   *
   * This function never blocks. It either immediately fails or immediately returns successfully
   * with a `resolve-address-stream` that can be used to (asynchronously) fetch the results.
   *
   * # Typical errors
   * - `invalid-argument`: `name` is a syntactically invalid domain name or IP address.
   *
   * # References:
   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html>
   * - <https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>
   * - <https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo>
   * - <https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3>
   */

  public fun resolveAddresses(
      network: Network.Network,
      name: String
  ): Result<IpNameLookup.ResolveAddressStream> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      var handle = network.__handle.value

      val bytearray = name.encodeToByteArray()
      val len = bytearray.size
      val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()

      val ptr0 = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_resolveAddresses(handle, ptr, len, ptr0)
      freeAllComponentModelReallocAllocatedMemory()
      val result =
          if ((ptr0 + 0).ptr.loadUByte().toInt() == 0) {
            val resource =
                IpNameLookup.ResolveAddressStream(ResourceHandle((ptr0 + 4).ptr.loadInt()))

            Result<IpNameLookup.ResolveAddressStream>.success(resource)
          } else {
            Result<IpNameLookup.ResolveAddressStream>
                .failure(
                    ComponentException(
                        Network.ErrorCode.values()[(ptr0 + 4).ptr.loadUByte().toInt()]))
          }
      return result
    }
    // </editor-fold>
  }
}

object Random {
  /**
   * Return `len` cryptographically-secure random or pseudo-random bytes.
   *
   * This function must produce data at least as cryptographically secure and fast as an adequately
   * seeded cryptographically-secure pseudo-random number generator (CSPRNG). It must not block,
   * from the perspective of the calling program, under any circumstances, including on the first
   * request and on requests for numbers of bytes. The returned data must always be unpredictable.
   *
   * This function must always return fresh data. Deterministic environments must omit this
   * function, rather than implementing it with deterministic data.
   */
  public fun getRandomBytes(len: ULong): List<UByte> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_getRandomBytes(len.toLong(), ptr)
      freeAllComponentModelReallocAllocatedMemory()

      val list = ArrayList<UByte>((ptr + 4).ptr.loadInt())
      for (i in 0 until (ptr + 4).ptr.loadInt()) {
        val base = ((ptr + 0).ptr.loadInt()) + (i * 1)

        list.add((base + 0).ptr.loadUByte().toInt().toUByte())
      }
      return list
    }
    // </editor-fold>
  }
  /**
   * Return a cryptographically-secure random or pseudo-random `u64` value.
   *
   * This function returns the same type of data as `get-random-bytes`, represented as a `u64`.
   */
  public fun getRandomU64(): ULong {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Long = __wasm_import_getRandomU64()
      freeAllComponentModelReallocAllocatedMemory()
      return ret.toULong()
    }
    // </editor-fold>
  }
}

object Insecure {
  /**
   * Return `len` insecure pseudo-random bytes.
   *
   * This function is not cryptographically secure. Do not use it for anything related to security.
   *
   * There are no requirements on the values of the returned bytes, however implementations are
   * encouraged to return evenly distributed values with a long period.
   */
  public fun getInsecureRandomBytes(len: ULong): List<UByte> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
      __wasm_import_getInsecureRandomBytes(len.toLong(), ptr)
      freeAllComponentModelReallocAllocatedMemory()

      val list = ArrayList<UByte>((ptr + 4).ptr.loadInt())
      for (i in 0 until (ptr + 4).ptr.loadInt()) {
        val base = ((ptr + 0).ptr.loadInt()) + (i * 1)

        list.add((base + 0).ptr.loadUByte().toInt().toUByte())
      }
      return list
    }
    // </editor-fold>
  }
  /**
   * Return an insecure pseudo-random `u64` value.
   *
   * This function returns the same type of pseudo-random data as `get-insecure-random-bytes`,
   * represented as a `u64`.
   */
  public fun getInsecureRandomU64(): ULong {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ret: Long = __wasm_import_getInsecureRandomU64()
      freeAllComponentModelReallocAllocatedMemory()
      return ret.toULong()
    }
    // </editor-fold>
  }
}

object InsecureSeed {
  /**
   * Return a 128-bit value that may contain a pseudo-random value.
   *
   * The returned value is not required to be computed from a CSPRNG, and may even be entirely
   * deterministic. Host implementations are encouraged to provide pseudo-random values to any
   * program exposed to attacker-controlled content, to enable DoS protection built into many
   * languages' hash-map implementations.
   *
   * This function is intended to only be called once, by a source language to initialize Denial Of
   * Service (DoS) protection in its hash-map implementation.
   *
   * # Expected future evolution
   *
   * This will likely be changed to a value import, to prevent it from being called multiple times
   * and potentially used for purposes other than DoS protection.
   */
  public fun insecureSeed(): Pair<ULong, ULong> {
    // <editor-fold defaultstate="collapsed" desc="Generated Bindings Code">
    withScopedMemoryAllocator { allocator ->
      val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=8)*/ allocator.allocate(16).address.toInt()
      __wasm_import_insecureSeed(ptr)
      freeAllComponentModelReallocAllocatedMemory()
      return Pair<ULong, ULong>(
          (ptr + 0).ptr.loadLong().toULong(),
          (ptr + 8).ptr.loadLong().toULong(),
      )
    }
    // </editor-fold>
  }
}

interface IfaceExports {

  data class Ab(
      var a: String,
      var b: String,
  )

  sealed interface V {
    data class A(val value: Int) : V

    data class B(val value: Float) : V
  }

  enum class Color {
    HOT_PINK,
    LIME_GREEN,
    NAVY_BLUE,
  }

  value class Fg internal constructor(val _value: Long) {
    constructor(
        a: Boolean = false,
        b: Boolean = false,
        c: Boolean = false,
        d: Boolean = false,
        e: Boolean = false,
    ) : this(
        0L or
            (if (a) (1L shl 0) else 0L) or
            (if (b) (1L shl 1) else 0L) or
            (if (c) (1L shl 2) else 0L) or
            (if (d) (1L shl 3) else 0L) or
            (if (e) (1L shl 4) else 0L))

    val a: Boolean
      get() = (_value and (1L shl 0)) != 0L

    val b: Boolean
      get() = (_value and (1L shl 1)) != 0L

    val c: Boolean
      get() = (_value and (1L shl 2)) != 0L

    val d: Boolean
      get() = (_value and (1L shl 3)) != 0L

    val e: Boolean
      get() = (_value and (1L shl 4)) != 0L
  }

  abstract fun markdownToHtml(x: String): String

  abstract fun test1(
      p1: Boolean,
      p2: Byte,
      p3: Short,
      p4: Int,
      p5: Long,
      p6: UByte,
      p7: UShort,
      p8: UInt,
      p9: ULong,
      p10: Int
  ): String

  abstract fun test2(x: List<String?>): List<String>

  abstract fun test3(x: Option<Option<Int?>>): Int

  abstract fun testRecord(x: IfaceExports.Ab): IfaceExports.Ab

  abstract fun testResult(x: Boolean): Result<Int>

  abstract fun testTuple(
      x1: Boolean,
      x2: Pair<Boolean, String>,
      x3: Triple<Boolean, String, Int>
  ): Tuple6<Boolean, Boolean, String, Boolean, String, Int>

  abstract fun testVariant(x: IfaceExports.V): IfaceExports.V

  abstract fun testEnum(x: IfaceExports.Color): Int

  abstract fun testFlags(x: IfaceExports.Fg): String
}

interface TestExports {
  abstract class TestExportedResource : AutoCloseable {
    internal var __handle: ResourceHandle = ResourceHandle(0)

    override fun close() {
      __cm_resource_abi_export_TestExportsImpl_TestExportedResource_drop(__handle.value)
    }

    abstract fun getA(): Int

    abstract fun setA(a: Int): Unit

    interface Statics {
      abstract fun add(
          x: TestExportsImpl.TestExportedResourceImpl,
          a: Int
      ): TestExportsImpl.TestExportedResourceImpl
    }
  }

  abstract fun test(): Unit
}
