// Generated by `wit-bindgen` 0.19.2. DO NOT EDIT!

@file:OptIn(UnsafeWasmMemoryApi::class)

import kotlin.wasm.unsafe.*
class ComponentException(val value: Any?) : Throwable()

sealed interface Option<out T> {
  data class Some<T2>(val value: T2) : Option<T2>
  data object None : Option<Nothing>
}

@WasmExport
fun cabi_realloc(ptr: Int, oldSize: Int, align: Int, newSize: Int): Int =
componentModelRealloc(ptr, oldSize, newSize)

fun MemoryAllocator.STRING_TO_MEM(s: String): Int =
writeToLinearMemory(s.encodeToByteArray()).address.toInt()

fun STRING_FROM_MEM(addr: Int, len: Int): String =
loadByteArray(addr.ptr, len).decodeToString()

fun MALLOC(size: Int, align: Int): Int = TODO()

val Int.ptr: Pointer
get() = Pointer(this.toUInt())

fun Pointer.loadUByte(): UByte = loadByte().toUByte()
fun Pointer.loadUShort(): UShort = loadShort().toUShort()
fun Pointer.loadUInt(): UInt = loadInt().toUInt()
fun Pointer.loadULong(): ULong = loadLong().toULong()

internal fun MemoryAllocator.writeToLinearMemory(value: String): Pointer =
writeToLinearMemory(value.encodeToByteArray())

internal fun loadString(addr: Pointer, size: Int): String =
loadByteArray(addr, size).decodeToString()
internal fun loadByteArray(addr: Pointer, size: Int): ByteArray =
ByteArray(size) { i -> (addr + i).loadByte() }
internal fun MemoryAllocator.writeToLinearMemory(array: ByteArray): Pointer {
  val pointer = allocate(array.size)
  var currentPointer = pointer
  array.forEach {
    currentPointer.storeByte(it)
    currentPointer += 1
  }
  return pointer
}


fun Pointer.loadFloat(): Float = Float.fromBits(loadInt())
fun Pointer.loadDouble(): Double = Double.fromBits(loadLong())
fun Pointer.storeFloat(value: Float) { storeInt(value.toRawBits()) }
fun Pointer.storeDouble(value: Double) { storeLong(value.toRawBits()) }

// -------------------------------------------------------

data class Tuple2<T0,T1,>(val f0: T0,val f1: T1,)
data class Tuple3<T0,T1,T2,>(val f0: T0,val f1: T1,val f2: T2,)
data class Tuple6<T0,T1,T2,T3,T4,T5,>(val f0: T0,val f1: T1,val f2: T2,val f3: T3,val f4: T4,val f5: T5,)
object Jsiface {
  class X(val __handle: Int)
  public fun constructorX(a: Int): Jsiface.X {
    withScopedMemoryAllocator { allocator -> 
    val ret: Int = __wasm_import_constructorX(a)
    freeAllComponentModelReallocAllocatedMemory();
    return Jsiface.X(ret)
  }
}
public fun methodX__getA(self: Jsiface.X): Int {
  withScopedMemoryAllocator { allocator -> 
  val ret: Int = __wasm_import_methodX__getA(self.__handle)
  freeAllComponentModelReallocAllocatedMemory();
  return ret
}
}
public fun methodX__setA(self: Jsiface.X, a: Int): Unit {
  withScopedMemoryAllocator { allocator -> 
  __wasm_import_methodX__setA(self.__handle, a)
  freeAllComponentModelReallocAllocatedMemory();
}
}
public fun staticX__add(x: Jsiface.X, a: Int): Jsiface.X {
  withScopedMemoryAllocator { allocator -> 
  val ret: Int = __wasm_import_staticX__add(x.__handle, a)
  freeAllComponentModelReallocAllocatedMemory();
  return Jsiface.X(ret)
}
}

}

@WasmImport("cm:example/jsiface", "[constructor]x")
private external fun __wasm_import_constructorX(p0: Int): Int

@WasmImport("cm:example/jsiface", "[method]x.get-a")
private external fun __wasm_import_methodX__getA(p0: Int): Int

@WasmImport("cm:example/jsiface", "[method]x.set-a")
private external fun __wasm_import_methodX__setA(p0: Int, p1: Int): Unit

@WasmImport("cm:example/jsiface", "[static]x.add")
private external fun __wasm_import_staticX__add(p0: Int, p1: Int): Int


object Iface {
  
  data class Ab(
  var a: String,
  var b: String,
  )
  sealed interface V{ 
    data class A(val value: Int) : V
    data class B(val value: Float) : V
  }
  enum class Color {
    HOT_PINK,
    LIME_GREEN,
    NAVY_BLUE,
  }
  
  value class Fg internal constructor(val _value: Long) {
    constructor(
    a: Boolean = false,b: Boolean = false,c: Boolean = false,d: Boolean = false,e: Boolean = false,
    ) : this(0L or (if (a) (1L shl 0) else 0L) or (if (b) (1L shl 1) else 0L) or (if (c) (1L shl 2) else 0L) or (if (d) (1L shl 3) else 0L) or (if (e) (1L shl 4) else 0L))
    val a: Boolean get() = (_value and (1L shl 0)) != 0L
    val b: Boolean get() = (_value and (1L shl 1)) != 0L
    val c: Boolean get() = (_value and (1L shl 2)) != 0L
    val d: Boolean get() = (_value and (1L shl 3)) != 0L
    val e: Boolean get() = (_value and (1L shl 4)) != 0L
  }
  public fun markdownToHtml(x: String): String {
    withScopedMemoryAllocator { allocator -> 
    
    val bytearray = x.encodeToByteArray()
    val len = bytearray.size
    val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()
    
    val ptr0 = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
    __wasm_import_markdownToHtml(ptr, len, ptr0)
    freeAllComponentModelReallocAllocatedMemory();
    return STRING_FROM_MEM((ptr0 + 0).ptr.loadInt(), (ptr0 + 4).ptr.loadInt())
  }
}
public fun test1(p1: Boolean, p2: Byte, p3: Short, p4: Int, p5: Long, p6: UByte, p7: UShort, p8: UInt, p9: ULong, p10: Int): String {
  withScopedMemoryAllocator { allocator -> 
  val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  __wasm_import_test1((if(p1) 1 else 0), p2.toInt(), p3.toInt(), p4, p5, p6.toInt(), p7.toInt(), p8.toInt(), p9.toLong(), p10, ptr)
  freeAllComponentModelReallocAllocatedMemory();
  return STRING_FROM_MEM((ptr + 0).ptr.loadInt(), (ptr + 4).ptr.loadInt())
}
}
public fun test2(x: List<String?>): List<String> {
  withScopedMemoryAllocator { allocator -> 
  
  val address = allocator.allocate(x.size * 12 /*, align=4*/).address.toInt()
  for ((index, el) in x.withIndex()) {
    val base = address + (index * 12)
    val payload0 = el
    if (payload0 != null) {
      (base + 0).ptr.storeByte(1.toByte())
      
      val bytearray = payload0.encodeToByteArray()
      val len = bytearray.size
      val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()
      
      (base + 8).ptr.storeInt(len)
      (base + 4).ptr.storeInt(ptr)
    } else {
      (base + 0).ptr.storeByte(0.toByte())
    }
    
  }
  val ptr1 = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  __wasm_import_test2(address, x.size, ptr1)
  freeAllComponentModelReallocAllocatedMemory();
  
  val list = ArrayList<String>((ptr1 + 4).ptr.loadInt())
  for (i in 0 until (ptr1 + 4).ptr.loadInt()) {
    val base = ((ptr1 + 0).ptr.loadInt()) + (i * 8)
    
    list.add(STRING_FROM_MEM((base + 0).ptr.loadInt(), (base + 4).ptr.loadInt()))
  }
  return list
}
}
public fun test3(x: Option<Option<Int?>>): Int {
  withScopedMemoryAllocator { allocator -> 
  val option11: Int
  val option12: Int
  val option13: Int
  val option14: Int
  val option15 = x
  if (option15 is Option.Some) {
    val payload0 = option15.value
    val option7: Int
    val option8: Int
    val option9: Int
    val option10 = payload0
    if (option10 is Option.Some) {
      val payload2 = option10.value
      val option: Int
      val option5: Int
      val payload4 = payload2
      if (payload4 != null) {
        option = 1
        option5 = payload4
      } else {
        option = 0
        option5 = 0
      }
      option7 = 1
      option8 = option
      option9 = option5
    } else {
      option7 = 0
      option8 = 0
      option9 = 0
    }
    option11 = 1
    option12 = option7
    option13 = option8
    option14 = option9
  } else {
    option11 = 0
    option12 = 0
    option13 = 0
    option14 = 0
  }
  val ret: Int = __wasm_import_test3(option11, option12, option13, option14)
  freeAllComponentModelReallocAllocatedMemory();
  return ret
}
}
public fun testRecord(x: Iface.Ab): Iface.Ab {
  withScopedMemoryAllocator { allocator -> 
  
  val bytearray = x.a.encodeToByteArray()
  val len = bytearray.size
  val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()
  
  
  val bytearray2 = x.b.encodeToByteArray()
  val len1 = bytearray2.size
  val ptr0 = allocator.writeToLinearMemory(bytearray2).address.toInt()
  
  val ptr3 = /* RETURN_ADDRESS_ALLOC(size=16, align=4)*/ allocator.allocate(16).address.toInt()
  __wasm_import_testRecord(ptr, len, ptr0, len1, ptr3)
  freeAllComponentModelReallocAllocatedMemory();
  return Iface.Ab(
  STRING_FROM_MEM((ptr3 + 0).ptr.loadInt(), (ptr3 + 4).ptr.loadInt()),
  STRING_FROM_MEM((ptr3 + 8).ptr.loadInt(), (ptr3 + 12).ptr.loadInt()),
  )
}
}
public fun testResult(x: Boolean): Result<Int> {
  withScopedMemoryAllocator { allocator -> 
  val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  __wasm_import_testResult((if(x) 1 else 0), ptr)
  freeAllComponentModelReallocAllocatedMemory();
  val result = if ((ptr + 0).ptr.loadUByte().toInt()== 0) {
    Result<Int>.success((ptr + 4).ptr.loadInt())
  } else {
    Result<Int>.failure(ComponentException((ptr + 4).ptr.loadInt()))
  }
  return result
}
}
public fun testTuple(x1: Boolean, x2: Pair<Boolean, String>, x3: Triple<Boolean, String, Int>): Tuple6<Boolean, Boolean, String, Boolean, String, Int> {
  withScopedMemoryAllocator { allocator -> 
  
  val bytearray = x2.second.encodeToByteArray()
  val len = bytearray.size
  val ptr = allocator.writeToLinearMemory(bytearray).address.toInt()
  
  
  val bytearray2 = x3.second.encodeToByteArray()
  val len1 = bytearray2.size
  val ptr0 = allocator.writeToLinearMemory(bytearray2).address.toInt()
  
  val ptr3 = /* RETURN_ADDRESS_ALLOC(size=28, align=4)*/ allocator.allocate(28).address.toInt()
  __wasm_import_testTuple((if(x1) 1 else 0), (if(x2.first) 1 else 0), ptr, len, (if(x3.first) 1 else 0), ptr0, len1, x3.third, ptr3)
  freeAllComponentModelReallocAllocatedMemory();
  return Tuple6<Boolean, Boolean, String, Boolean, String, Int>(
  ((ptr3 + 0).ptr.loadUByte().toInt() != 0),
  ((ptr3 + 1).ptr.loadUByte().toInt() != 0),
  STRING_FROM_MEM((ptr3 + 4).ptr.loadInt(), (ptr3 + 8).ptr.loadInt()),
  ((ptr3 + 12).ptr.loadUByte().toInt() != 0),
  STRING_FROM_MEM((ptr3 + 16).ptr.loadInt(), (ptr3 + 20).ptr.loadInt()),
  (ptr3 + 24).ptr.loadInt(),
  )
}
}
public fun testVariant(x: Iface.V): Iface.V {
  withScopedMemoryAllocator { allocator -> 
  // VariantLower START
  val variant: Int
  val variant1: Int
  when (val x2 = x) {
    is Iface.V.A -> {
      val payload = x2.value
      variant = 0;
      variant1 = payload;
    }
    is Iface.V.B -> {
      val payload0 = x2.value
      variant = 1;
      variant1 = payload0.toRawBits();
    }
    else -> error("unreachable")
  }
  // VariantLower END
  val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  __wasm_import_testVariant(variant, variant1, ptr)
  freeAllComponentModelReallocAllocatedMemory();
  // VariantLift START.
  val variant3 = when ((ptr + 0).ptr.loadUByte().toInt()) {
    0 -> {
      Iface.V.A((ptr + 4).ptr.loadInt())
    }
    1 -> {
      Iface.V.B((ptr + 4).ptr.loadFloat())
    }
    else -> error("unreachable")
  }
  // VariantLift END
  return variant3
}
}
public fun testEnum(x: Iface.Color): Int {
  withScopedMemoryAllocator { allocator -> 
  val ret: Int = __wasm_import_testEnum(x.ordinal)
  freeAllComponentModelReallocAllocatedMemory();
  return ret
}
}
public fun testFlags(x: Iface.Fg): String {
  withScopedMemoryAllocator { allocator -> 
  val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  __wasm_import_testFlags(x._value.toInt(), ptr)
  freeAllComponentModelReallocAllocatedMemory();
  return STRING_FROM_MEM((ptr + 0).ptr.loadInt(), (ptr + 4).ptr.loadInt())
}
}

}

@WasmImport("cm:example/iface", "markdown-to-html")
private external fun __wasm_import_markdownToHtml(p0: Int, p1: Int, p2: Int): Unit

@WasmImport("cm:example/iface", "test1")
private external fun __wasm_import_test1(p0: Int, p1: Int, p2: Int, p3: Int, p4: Long, p5: Int, p6: Int, p7: Int, p8: Long, p9: Int, p10: Int): Unit

@WasmImport("cm:example/iface", "test2")
private external fun __wasm_import_test2(p0: Int, p1: Int, p2: Int): Unit

@WasmImport("cm:example/iface", "test3")
private external fun __wasm_import_test3(p0: Int, p1: Int, p2: Int, p3: Int): Int

@WasmImport("cm:example/iface", "test-record")
private external fun __wasm_import_testRecord(p0: Int, p1: Int, p2: Int, p3: Int, p4: Int): Unit

@WasmImport("cm:example/iface", "test-result")
private external fun __wasm_import_testResult(p0: Int, p1: Int): Unit

@WasmImport("cm:example/iface", "test-tuple")
private external fun __wasm_import_testTuple(p0: Int, p1: Int, p2: Int, p3: Int, p4: Int, p5: Int, p6: Int, p7: Int, p8: Int): Unit

@WasmImport("cm:example/iface", "test-variant")
private external fun __wasm_import_testVariant(p0: Int, p1: Int, p2: Int): Unit

@WasmImport("cm:example/iface", "test-enum")
private external fun __wasm_import_testEnum(p0: Int): Int

@WasmImport("cm:example/iface", "test-flags")
private external fun __wasm_import_testFlags(p0: Int, p1: Int): Unit


interface IfaceExports {
  
  data class Ab(
  var a: String,
  var b: String,
  )
  sealed interface V{ 
    data class A(val value: Int) : V
    data class B(val value: Float) : V
  }
  enum class Color {
    HOT_PINK,
    LIME_GREEN,
    NAVY_BLUE,
  }
  
  value class Fg internal constructor(val _value: Long) {
    constructor(
    a: Boolean = false,b: Boolean = false,c: Boolean = false,d: Boolean = false,e: Boolean = false,
    ) : this(0L or (if (a) (1L shl 0) else 0L) or (if (b) (1L shl 1) else 0L) or (if (c) (1L shl 2) else 0L) or (if (d) (1L shl 3) else 0L) or (if (e) (1L shl 4) else 0L))
    val a: Boolean get() = (_value and (1L shl 0)) != 0L
    val b: Boolean get() = (_value and (1L shl 1)) != 0L
    val c: Boolean get() = (_value and (1L shl 2)) != 0L
    val d: Boolean get() = (_value and (1L shl 3)) != 0L
    val e: Boolean get() = (_value and (1L shl 4)) != 0L
  }
  fun markdownToHtml(x: String): String
  fun test1(p1: Boolean, p2: Byte, p3: Short, p4: Int, p5: Long, p6: UByte, p7: UShort, p8: UInt, p9: ULong, p10: Int): String
  fun test2(x: List<String?>): List<String>
  fun test3(x: Option<Option<Int?>>): Int
  fun testRecord(x: IfaceExports.Ab): IfaceExports.Ab
  fun testResult(x: Boolean): Result<Int>
  fun testTuple(x1: Boolean, x2: Pair<Boolean, String>, x3: Triple<Boolean, String, Int>): Tuple6<Boolean, Boolean, String, Boolean, String, Int>
  fun testVariant(x: IfaceExports.V): IfaceExports.V
  fun testEnum(x: IfaceExports.Color): Int
  fun testFlags(x: IfaceExports.Fg): String
  
}

@WasmExport("cm:example/iface#markdown-to-html")
fun __wasm_export_markdownToHtml(p0: Int, p1: Int): Int {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  
  val result: String = IfaceExportsImpl.markdownToHtml(STRING_FROM_MEM(p0, p1))
  
  val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  
  val bytearray = result.encodeToByteArray()
  val len = bytearray.size
  val ptr0 = allocator.writeToLinearMemory(bytearray).address.toInt()
  
  (ptr + 4).ptr.storeInt(len)
  (ptr + 0).ptr.storeInt(ptr0)
  return ptr
}
}

@WasmExport("cm:example/iface#test1")
fun __wasm_export_test1(p0: Int, p1: Int, p2: Int, p3: Int, p4: Long, p5: Int, p6: Int, p7: Int, p8: Long, p9: Int): Int {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  
  val result: String = IfaceExportsImpl.test1((p0 != 0), p1.toByte(), p2.toShort(), p3, p4, p5.toUByte(), p6.toUShort(), p7.toUInt(), p8.toULong(), p9)
  
  val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  
  val bytearray = result.encodeToByteArray()
  val len = bytearray.size
  val ptr0 = allocator.writeToLinearMemory(bytearray).address.toInt()
  
  (ptr + 4).ptr.storeInt(len)
  (ptr + 0).ptr.storeInt(ptr0)
  return ptr
}
}

@WasmExport("cm:example/iface#test2")
fun __wasm_export_test2(p0: Int, p1: Int): Int {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  
  val list = ArrayList<String?>(p1)
  for (i in 0 until p1) {
    val base = (p0) + (i * 12)
    // OptionLift start
    val option = if ((base + 0).ptr.loadUByte().toInt()== 1) {
      STRING_FROM_MEM((base + 4).ptr.loadInt(), (base + 8).ptr.loadInt())
    } else {
      null
    }
    // OptionLift end
    
    list.add(option)
  }
  
  val result: List<String> = IfaceExportsImpl.test2(list)
  
  val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  
  val address = allocator.allocate(result.size * 8 /*, align=4*/).address.toInt()
  for ((index, el) in result.withIndex()) {
    val base = address + (index * 8)
    
    val bytearray = el.encodeToByteArray()
    val len = bytearray.size
    val ptr0 = allocator.writeToLinearMemory(bytearray).address.toInt()
    
    (base + 4).ptr.storeInt(len)
    (base + 0).ptr.storeInt(ptr0)
    
  }
  (ptr + 4).ptr.storeInt(result.size)
  (ptr + 0).ptr.storeInt(address)
  return ptr
}
}

@WasmExport("cm:example/iface#test3")
fun __wasm_export_test3(p0: Int, p1: Int, p2: Int, p3: Int): Int {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  // OptionLift start
  val option1 = if (p0== 1) {
    // OptionLift start
    val option0 = if (p1== 1) {
      // OptionLift start
      val option = if (p2== 1) {
        p3
      } else {
        null
      }
      // OptionLift end
      Option.Some(option)
    } else {
      Option.None
    }
    // OptionLift end
    Option.Some(option0)
  } else {
    Option.None
  }
  // OptionLift end
  
  val result: Int = IfaceExportsImpl.test3(option1)
  
  return result
}
}

@WasmExport("cm:example/iface#test-record")
fun __wasm_export_testRecord(p0: Int, p1: Int, p2: Int, p3: Int): Int {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  
  val result: IfaceExports.Ab = IfaceExportsImpl.testRecord(IfaceExports.Ab(
  STRING_FROM_MEM(p0, p1),
  STRING_FROM_MEM(p2, p3),
  ))
  
  val ptr = /* RETURN_ADDRESS_ALLOC(size=16, align=4)*/ allocator.allocate(16).address.toInt()
  
  val bytearray = result.a.encodeToByteArray()
  val len = bytearray.size
  val ptr0 = allocator.writeToLinearMemory(bytearray).address.toInt()
  
  (ptr + 4).ptr.storeInt(len)
  (ptr + 0).ptr.storeInt(ptr0)
  
  val bytearray3 = result.b.encodeToByteArray()
  val len2 = bytearray3.size
  val ptr1 = allocator.writeToLinearMemory(bytearray3).address.toInt()
  
  (ptr + 12).ptr.storeInt(len2)
  (ptr + 8).ptr.storeInt(ptr1)
  return ptr
}
}

@WasmExport("cm:example/iface#test-result")
fun __wasm_export_testResult(p0: Int): Int {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  
  val result: Result<Int> = IfaceExportsImpl.testResult((p0 != 0))
  
  val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  if (result.isFailure) {
    val payload0 = (result.exceptionOrNull() as ComponentException).value as Int
    (ptr + 0).ptr.storeByte(1.toByte())
    (ptr + 4).ptr.storeInt(payload0)
  } else {
    val payload = result.getOrThrow()!!
    (ptr + 0).ptr.storeByte(0.toByte())
    (ptr + 4).ptr.storeInt(payload)
  }
  return ptr
}
}

@WasmExport("cm:example/iface#test-tuple")
fun __wasm_export_testTuple(p0: Int, p1: Int, p2: Int, p3: Int, p4: Int, p5: Int, p6: Int, p7: Int): Int {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  
  val result: Tuple6<Boolean, Boolean, String, Boolean, String, Int> = IfaceExportsImpl.testTuple((p0 != 0), Pair<Boolean, String>(
  (p1 != 0),
  STRING_FROM_MEM(p2, p3),
  ), Triple<Boolean, String, Int>(
  (p4 != 0),
  STRING_FROM_MEM(p5, p6),
  p7,
  ))
  
  val ptr = /* RETURN_ADDRESS_ALLOC(size=28, align=4)*/ allocator.allocate(28).address.toInt()
  (ptr + 0).ptr.storeByte((if(result.f0) 1 else 0).toByte())
  (ptr + 1).ptr.storeByte((if(result.f1) 1 else 0).toByte())
  
  val bytearray = result.f2.encodeToByteArray()
  val len = bytearray.size
  val ptr0 = allocator.writeToLinearMemory(bytearray).address.toInt()
  
  (ptr + 8).ptr.storeInt(len)
  (ptr + 4).ptr.storeInt(ptr0)
  (ptr + 12).ptr.storeByte((if(result.f3) 1 else 0).toByte())
  
  val bytearray3 = result.f4.encodeToByteArray()
  val len2 = bytearray3.size
  val ptr1 = allocator.writeToLinearMemory(bytearray3).address.toInt()
  
  (ptr + 20).ptr.storeInt(len2)
  (ptr + 16).ptr.storeInt(ptr1)
  (ptr + 24).ptr.storeInt(result.f5)
  return ptr
}
}

@WasmExport("cm:example/iface#test-variant")
fun __wasm_export_testVariant(p0: Int, p1: Int): Int {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  // VariantLift START.
  val variant = when (p0) {
    0 -> {
      IfaceExports.V.A(p1)
    }
    1 -> {
      IfaceExports.V.B(Float.fromBits(p1))
    }
    else -> error("unreachable")
  }
  // VariantLift END
  
  val result: IfaceExports.V = IfaceExportsImpl.testVariant(variant)
  
  val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  // VariantLower START
  when (val x = result) {
    is IfaceExports.V.A -> {
      val payload = x.value
      (ptr + 0).ptr.storeByte(0.toByte())
      (ptr + 4).ptr.storeInt(payload)
    }
    is IfaceExports.V.B -> {
      val payload0 = x.value
      (ptr + 0).ptr.storeByte(1.toByte())
      (ptr + 4).ptr.storeFloat(payload0)
    }
    else -> error("unreachable")
  }
  // VariantLower END
  return ptr
}
}

@WasmExport("cm:example/iface#test-enum")
fun __wasm_export_testEnum(p0: Int): Int {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  
  val result: Int = IfaceExportsImpl.testEnum(IfaceExports.Color.values()[p0])
  
  return result
}
}

@WasmExport("cm:example/iface#test-flags")
fun __wasm_export_testFlags(p0: Int): Int {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  
  val result: String = IfaceExportsImpl.testFlags(IfaceExports.Fg(p0.toLong()))
  
  val ptr = /* RETURN_ADDRESS_ALLOC(size=8, align=4)*/ allocator.allocate(8).address.toInt()
  
  val bytearray = result.encodeToByteArray()
  val len = bytearray.size
  val ptr0 = allocator.writeToLinearMemory(bytearray).address.toInt()
  
  (ptr + 4).ptr.storeInt(len)
  (ptr + 0).ptr.storeInt(ptr0)
  return ptr
}
}


interface TestExports {
  fun test(): Unit
  
}

@WasmExport("cm:example/test#test")
fun __wasm_export_test(): Unit {
  freeAllComponentModelReallocAllocatedMemory()
  withScopedMemoryAllocator { allocator -> 
  
  TestExportsImpl.test()
  
}
}


